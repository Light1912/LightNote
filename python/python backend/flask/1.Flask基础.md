真的反反复复学习了好多次了。

本来想等《Flask Web 开发实战》第二版，但是这会包含很多不确定性，还是算了。

第一版下载：[【百度云】](https://pan.baidu.com/s/1PkV54TnQmhaTlOTA5QpjTA?pwd=aj5u) [【勘误表】](https://docs.helloflask.com/book/1/errata/1-1/)

https://www.12factor.net/zh_cn/


感觉学习需要一个框架，不然每次过了很久再回来重新学，都要重新看教材，太麻烦了啊。关键这个我自己也总结不好，挺头疼的。

总之，这个文档的内容重在使用，类似于工具文档，是上面这本书知识点的精简版。

该解释的解释一下下就好。

# 初识Flask

### 环境准备

在任意路径创建一个名为`flask_study`的文件夹。

在该目录下运行以下命令

创建虚拟环境

```
python -m venv venv
```

linux激活虚拟环境

```
source ./venv/bin/activate	
```

windows激活虚拟环境

```
.\venv\Scripts\activate
```

安装包管理工具`pip-tools`

```
pip install pip-tools
```

在`flask_study`目录下创建`requirements.in`文件并填入以下内容

```
flask==2.0.2
```

> 也可以不指定flask版本

编译依赖包

```
pip-compile ./requirements.in
```

安装依赖包

```
pip-sync
```



至此就完成了flask的基础环境配置，当前目录文件如下

```
  |- flask_study
    |- venv
    |- requirements.in
    |- requirements.txt
```

> 如果环境中安装了Flask，只想快速测试Flask的功能，也可以不进行上述步骤

### 第一个Flask程序

创建`app.py`文件，内容：

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return "<h1>hello world!</h1>"
```

运行该服务器

```
flask run
```

```
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

访问：http://127.0.0.1:5000/ 即可看到hello world!



其中`index()`函数被称为视图函数view。

这个名词来源于 MVC架构 (Model-View-Controller，模型－视图－控制器）



### 路由基本使用

每个函数的路由用`@app.route('/xxx')`装饰器来定义。

被定义的函数叫**视图**，比如`index()`函数就是一个视图

路由的常见用法如下：

- 一个视图可以绑定多个URL
- 动态URL：URL可以传参数

代码案例

```python
from flask import Flask

app = Flask(__name__)

# 一个视图绑定多个URL
@app.route("/buy", defaults={"goods": "coffee"})
@app.route("/buy/<goods>")
def buy(goods):
    return "you bought %s" % goods

# 动态URL
@app.route("/hello/<name>")
def hello(name):
    return "hello %s!" % name

if __name__ == '__main__':
    app.run()
```

测试

- http://127.0.0.1:5000/hello: 404
- http://127.0.0.1:5000/hello/lily: 显示hello lily
- http://127.0.0.1:5000/buy：显示you bought coffee
- http://127.0.0.1:5000/buy/flower: 显示you bought flower

### 获取query字符串

```python
from flask import Flask, request
app = Flask(__name__)

@app.route('/hello')
def hello():
    name = request.args.get('name', '...')
    return "hello, %s!" % name
```

测试

- http://127.0.0.1:5000/hello
- http://127.0.0.1:5000/hello?name=world

模拟发送请求

```python
import requests
url = 'http://127.0.0.1:5000/hello'
# 不传参数
resp = requests.get(url)
print(resp.text)
# 传入参数
# 同 http://127.0.0.1:5000/hello?name=world
resp = requests.get(url, params={'name': 'world'})
print(resp.text)
```

```
hello, ...!
hello, world!
```



### flask run

`flask run`默认监听http://127.0.0.1:5000/，并开启**多线程支持**，会自动寻找`app.py`文件来运行。

可以通过修改环境变量来修改程序主模块，比如想运行`hello.py`，就可以修改环境变量`FLASK_APP`

linux

```
export FLASK_APP=hello
```

windows

```
set FLASK_APP=hello
```

**使服务器外部可见**

```
flask run --host=0.0.0.0
```

**改变端口**

```
flask run --port=8000
```

**查看其他命令**

```
flask --help
```

> 以前是通过`app.run()`来启动服务器，现在不推荐了。
>
> 建议统一使用`flask run`+环境变量配置的方式来启动服务器。

### 环境变量管理

默认情况下flask会加载系统的环境变量，可以安装`python-dotenv`来管理Flask的环境变量。

```
pip install python-dotenv
```



创建`.env`，`.flaskenv`两个文件来配置环境变量。



优先级为：

- 手动设置
- `.env`：存储密码等敏感设置环境变量
- `.flaskenv`：存储公开环境变量

通用格式

```
FLASK_<命令>_<选项>
```

可以用`flask --help`来查看所有可用命令



常用环境变量

```
FLASK_APP=app
FLASK_RUN_HOST=127.0.0.1
FLASK_RUN_PORT=5000
FLASK_ENV=development
```

解释：

- `FLASK_ENV`，默认为生产环境（production），开发过程中可以设置为development。

> 'FLASK_ENV' is deprecated and will not be used in Flask 2.3. Use 'FLASK_DEBUG' instead.

2.3版本以后使用

```
FLASK_DEBUG = True
```



### 调试和重载

**调试**

在开发环境下会自动开启调试模式（Debug Mode）

```
flask run
```

```
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 636-634-369
```

点击错误信息右侧的命令行图标， 会弹出窗口要求输入PIN 码。

也就是在启动服务器时命令行窗口打印出`Debugger PIN` 。

输入PIN 码后，我们可以点击错误堆栈的某个节点右侧的命令行界面图标，这会打开一
个包含代码执行上下文信息的Python Shell ，我们可以利用它来进行调试。

**重载**

重载的作用是当修改代码保存后，服务器会自动重启。

比如随意修改`app.py`并`ctrl+s`保存后终端会显示

```
 * Detected change in 'E:\flask_study\app.py', reloading
 * Restarting with stat
```

默认会使用Werkzeug 内置的stat 重载器，推荐使用`watchdog`库，据说效果更好

```
pip install watchdog
```

### flask shell

主要是为了调试，用flask shell会获得跟app一样的环境。

```
flask shell
```

```
Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] on win32
App: app [development]
Instance: E:\flask_study\instance
```

后面的带有`>>>`的代码片段就表示是在shell中的输入，在这个终端中输入

```
>>> app
<Flask 'app'>
>>> app.name
'app'
```

> 后续会有更详细的介绍

### Flask扩展

通用的flask扩展加载方式如下

```python
from flask import Flask
from flask_foo import Foo

app = Flask(__name__)
foo = Foo(app)
```

通常扩展是作为Flask和其他库之间的一层胶水。

### 项目配置

设置配置

键值对配置

```python
app.config['ADMIN_NAME'] = 'Lily'
```

update方法

```python
app.config.update(
    TESTING=True,
    SECRET_KEY='xxxxx'
)
```

还可以将配置变量存储在单独python脚本、JSON文件、python类等



读取配置

```python
admin_name = app.config('ADMIN_NAME')
```

### URL与端点

推荐使用`url_for()`函数来获取URL，该函数的第一个参数就是**端点值(endpoint)**

比如下面这个例子中：

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello World!'

@app.route('/hello/<name>')
def hello(name):
    return "hello, %s!" % name
```

调用`url_for('index')`就可以得到`/`

而调用`url_for('hello', name='jack')`就会得到`/hello/jack`

`url_for('hello', _external=True, name='jack')`

得到`http://localhost:5000/hello/jack`





### Flask命令

可以自定义Flask命令

```python
# app.py
from flask import Flask
import click
app = Flask(__name__)

@app.cli.command()
def greeting():
    click.echo('hello!')
```

在命令行

```
flask greeting
```

```
hello
```

> 更多自定义命令可以参考http://click.pocoo.org/6/

常用命令介绍

**查看程序中定义的所有路由**

```
flask routes
```





### 模板与静态文件

通常模板文件放在`templates`文件夹

静态文件放在`static`文件夹

```
|- flask_study
  |- templates/
  |- static/
  |- app.py
```

开发环境下建议用本地资源

# Flask与HTTP

## HTTP请求

### Request对象

假设请求URL为：http://localhost:5000/hello?name=Light

获取到的request属性为

```python
request.path  # u'/hello'
request.full_path
request.host
request.host_url
request.base_url
request.url
request.url_root


```

例如：获取查询字符串

```python
from flask import Flask, request
app = Flask(__name__)

@app.route('/hello')
def hello():
    name = request.args.get('name', 'Flask')
    return f'hello {name}'
```

其他常用属性和方法

```python
request.args
request.blueprint  # 当前蓝图名称
request.cookies  # 随请求提交的cookies字典
data  # string, 请求数据
endpoint  # string, 当前请求的端点值
files  # MultiDict对象，所有上传文件，key为input标签中的name
form  # ImmutableMultiDict，解析后的表单数据，key为input标签中的name
values  # CombineMultiDict，结合了args和form

# 获取请求中的数据，默认读取为字节字符串(bytestring)
# as_test=True 会返回解码后的unicode字符串
get_data(cache=True, as_text=True, parse_from_data=False)

# 返回json数据，若MIME类型不是JSON，则返回None
# silent=True, 解析出错返回None，否则400
get_json(self, force=False, silent=False, cache=True)

headers  # EnvironHeaders对象，可以以字典形式操作
is_json  # bool, 通过MIME类型判断是否为JSON数据
json  # 内部调用get_json()
method  # 请求的HTTP方法
referrer  # 请求发起的源URL，即referer
scheme  # 请求的URL模式（http 或 https)
user_agent  # 用户代理信息
```

> MultiDict类是字典之类，实现了一个键对应多个值的情况（一个文件上传字段可能会接收多个文件）。
>
> 通过`getlist()`方法获取文件对象列表。
>
> `ImmutableMultiDict`的值不可修改
>
> 参考：http://werkzeug.pocoo.org/docs/latest/datastructures/

### 设置http方法

默认是GET方法，可以通过给`methods`参数传入一个列表来选择方法

测试案例

```python
@app.route('/test_post', methods=['POST'])
def test_post():
    data = json.loads(request.get_data())
    data['score'] = 100
    return jsonify(data)
```

获取响应数据

```python
data = {
    'name': 'lily',
    'age': 19
}
resp = requests.post("http://127.0.0.1:5000/test_post", json=data)
print(resp.json())
```



### URL参数转换器

路由可以指定参数的数据类型，默认都是string，可以指定不同的转换器

```python
@app.route('hello/<int:year>')
@app.route('hello/<float:month>')
# 包含斜线的字符串，static路由的URL规则中的filename变量就用这个转换器
@app.route('hello/<path:file_save_path>')

# 匹配配一系列给定值中的一个元素
@app.route('hello/<any(blue, white, red):color>')

@app.route('hello/<uuid:merchant_id>')
```

### 请求钩子

作用：用于在进行请求处理前、后执行一些代码。

比如以下5个请求钩子

```python
# 处理第一个请求前运行
@app.before_first_request

# 处理每个请求前运行
@app.before_request

# 每个请求结束后运行，如果没有未处理的异常抛出
@app.after_request

# 每个请求结束后运行
# 如果发生异常，会传入异常对象作为参数到注册的函数中
@app.teardown_request

# 在视图函数内注册一个函数， 会在这个请求结束后运行
@app.after_this_request
```

请求处理函数调用示意图如下

![请求处理函数调用示意图.drawio](images/请求处理函数调用示意图.drawio.svg)

**应用场景**

- before_first_request：运行程序前执行的初始化操作，创建数据库表、添加管理员用户等
- before_request：记录用户的最后在线时间。
- after_request：视图函数中进行了数据库的操作，进行完毕后提交修改

> after_request 钩子和after_this request 钩子必须接收一个响应类对象作为参数，并且返回同一个或更新后的响应对象。
>
> ? 没看懂

## HTTP响应

### 响应报文

```
HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 17
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Sat, 08 Jan 2022 06:45:34 GMT
```

对应

```
协议 状态码 原因短语  # 状态行       ─┐
key1: value1       # ─┐           |
...                #  ├ 首部字段   |- 报文首部
keyn: valuen       # ─┘          ─┘
                   # 空行：用于隔开报文首部和报文主体
<h1>hello</h1>     # ─┐
...                #  ├ 报文主体
...                # ─┘
```

### 常见HTTP状态码

| 状态码 | 原因短语              | 说明                                                         |
| ------ | --------------------- | ------------------------------------------------------------ |
| 200    | OK                    | 请求被正常处理                                               |
| 201    | Created               | 请求被处理，并创建了一个新资源                               |
| 204    | No Content            | 请求处理成功，但无内容返回                                   |
| 301    | Moved Permanently     | 永久重定向                                                   |
| 302    | Found                 | 临时性重定向                                                 |
| 304    | Not Modified          | 请求的资源未被修改，重定向到缓存的资源                       |
| 400    | Bad Prequest          | 表示请求无效，即请求报文中存在错误                           |
| 401    | Unauthorized          | 类似403，表示请求的资源需要获取授权信息，在浏览器中会弹出认证弹窗 |
| 403    | Forbidden             | 表示请求的资源被服务器拒绝访问                               |
| 404    | Not Found             | 表示服务器上无法找到请求的或URL无效                          |
| 500    | Internal Server Error | 服务器内部发生错误                                           |

响应状态码详细列表：https://tools.ietf.org/html/rfc7231

### Flask响应方式

就是视图函数的响应方式，举例如下

```python
# 方式1：只返回响应主体
@app.route('/hello')
def hello():
    return 'hello'

# 方式2：返回响应主体、状态码
@app.route('/hello')
def hello():
    return 'hello', 201

# 方式3：返回响应主体、状态码、首部字段
@app.route('/hello')
def hello():
    return 'hello', 302, {'Location':'http://www.example.com'}
```

> 视图函数可以返回最多由三个元素组成的元组：响应主体、状态码、首部字段

### 重定向

就是网页跳转

这个视图函数就是一个重定向的例子

```python
@app.route('/hello')
def hello():
    return 'hello', 302, {'Location':'http://www.baidu.com'}
```

在flask中可以简化为

```python
from flask import Flask, redirect
@app.route('/hello')
def hello():
    return redirect('http://www.baidu.com')
```

重定向到其他视图

```python
from flask import Flask, redirect , url_for
@app.route('/')
def index():
    return 'hello'

@app.route('/hello')
def hello():
    return redirect(url_for('index'))
```

登录前想访问`/admin`页面，但是由于没登录，自动跳转到登录界面了。如何在用户完成登录后自动跳转到`/admin`页面？

```python
# 定义一个返回函数
def redirect_back(default='/', **kwargs):
    for target in request.args.get('next'), request.referrer:
        if target:
            return redirect(target)
    return redirect(url_for(default, **kwargs))

# 管理视图
@app.route('/admin')
def admin():
    if requests.cookies.get('login') is None:
        return redirect(url_for('login'), next=request.full_path)
    
# 登录视图
@app.route('/login')
def login():
    # do something...
    return redirect_back()
```





### 响应错误

一般用`abort()`返回指定的错误响应代码

```python
from flask import Flask, abort
@app.route('/404')
def not_found():
    abort(404)
```

> 无需调用return语句，会自动中断，abort后面的代码都不会执行

### 响应格式

大多数情况下，格式都是HTML。

通过改变Content-Type可以改变数据格式

```
Content-Type: text/html; charset=utf-8
```

> MIME类型(又称为media type或content type)
>
> 是一种用来标识文件类型的机制。与文件扩展名相对应。
>
> 格式为：类型名/子类型名。
>
> - text/html: 就是HTML的MIME类型
> - image/png: 就是png图片的MIME类型
>
> 可以参考：https://www.iana.org/assignments/media-types/media-types.xhtml

可以使用`make_response()`方法生成响应对象，传入响应的主体，然后设置该对象的mimetype属性

```python
from flask import make_reponse

@app.route('/foo')
def foo():
    response = make_reponse('Hello')
    response.mimetype = 'text/plain'
    # 效果相同
    # response.headers['Content-Type']='text/plain; charset=utf-8'
    return response
```

**MIME数据类型**

- text/html：默认的数据格式
- text/plain：纯文本，HTML标签会原封不动地展示出来
- application/xml：XML一般作为AJAX请求的响应格式，或是Web API的响应格式。
- application/json：flask提供了`jsonify()`函数可以方便地返回JSON响应

json用法

```python
# 参数方式
@app.route('/foo')
def foo():
    return jsonify(name='lily', age=18)

# 字典方式
@app.route('/foo')
def foo():
    jsonify({'name': 'lily', 'age', 18})

# 默认生成200响应，可以增加返回值以更改响应类型
@app.route('/foo')
def foo():
    jsonify(message='error'), 500
```

### Cookie

**为什么要用cookie**：HTTP是无状态协议(stateless)，在响应结束后，服务器不会留下任何关于对方状态的信息。

**如何理解cookie**：可以把cookie理解为保存在浏览器的小型文本数据。

**cookie运作方式**：浏览器接收到服务器发来的cookie之后，下次向同样服务器发请求时会携带cookie数据，存储在字段`Cookie`内。

**cookie使用场景**：

- 用户的登录状态
- 视频上次播放位置
- 语言偏好等

如何在flask中使用cookie

```python
from flask import make_response

@app.route('/set/<name>'):
    response = make_response(redirect(url_for('hello')))
    response.set_cookie('name', name)
    return response
```

这会在报文首部创建一个Set-Cookie字段

```
Set-Cookie: name=Lily;Path=/+
```

浏览器保存了cookie后，下次浏览器再向服务器发送请求时就会自动带上这个cookie

#### Response类的常用属性和方法

| 方法/属性    | 说明                                                    |
| ------------ | ------------------------------------------------------- |
| headers      | Werkzeug的Headers对象，表示响应首部，可以像字典一样操作 |
| status       | str，状态码                                             |
| status_code  | 状态码，整形                                            |
| mimetype     | MIME类型（仅包括内容类型部分）                          |
| set_cookie() | 用来设置一个cookie                                      |

> 此外也有`get_json()`、`is_json()`方法以及json属性

#### set_cookie()常用参数

| 参数     | 说明                                           |
| -------- | ---------------------------------------------- |
| key      | 键                                             |
| value    | 值                                             |
| max_age  | int, cookie被保存的时间                        |
| expires  | datetime对象或UNIX时间戳，具体过期时间         |
| path     | 限制cookie只在给定的路径可用，默认整个域名     |
| domain   | 设置cookie可用的域名                           |
| secure   | bool，若为True，只有通过HTTPS才可以使用        |
| httponly | bool，若为True，禁止客户端JavaScript获取cookie |

### Session

session可以理解为加密的Cookie。

有些敏感的数据，比如账号密码如果存在cookie里，那别人是可以伪装的。

> 注意这里的session是有差异的。
>
> Flask的session指加密的Cookie，存储在浏览器上的一个名为session的cookie里。
>
> 而编程中的session指**用户会话(user session)**，即服务器和客户端之前的交互活动。

#### 1.设置程序秘钥

作用：用于加密、解密数据，使用session必须先在配置文件加上SECRET_KEY

```python
app.secret_key = 'ABCD'
```

更安全的做法是写入环境变量，比如`.env`文件

```
SECRET_KEY = ABCD
```

然后在代码中获取

```python
import os
app.secret_key = os.getenv('SECRET_KEY', '默认秘钥')
```

#### 2. 模拟用户认证

创建session：

```python
from flask import session
...
@app.route('/login')
def login():
    session['logged_in'] = True
    return redirect(url_for('hello'))
```

当用户访问http://127.0.0.1:5000/login时

就会添加一个名为session的cookie，里边存着`logged_in`

除非知道秘钥，否则加密的session用户是无法修改的。

#### 如何使用session？

获取session

```python
@app.route('/hello')
def hello():
    name = request.args.get('name')
    if name is None:
        name = request.cookies.get('name', 'Human')
        response = f'hello, {name}!'
        if 'logged_in' in session:
            response += '[Authticated]'
        else:
            response += '[Not Authenticatetd]'
        return response
        
```

可以用`session['logged_in']`或`session.get('logged_in')`获取值。

案例二：通过判断是否登录决定用户能否访问到管理界面



```python
@app.route('/admin')
def admin():
    if 'logged_in' not in session:
        abort(403)
    return 'Welcome to admin page!'
```

#### 删除session项目

用户登出

```python
@app.route('/logout')
def logout():
    if 'logged_in' in session:
        session.pop('logged_in')
    return redirect(url_for('hello'))
```

删除所有session

```python
session.clear()
```





#### 其他

默认情况下session 会在用户关闭浏览器时删除

通过设置

```python
session.permanent = True
```

将session有效期延长至默认31天

通过环境变量`PERMANENT_SESSION_LIFETIME`来修改这个时间，这是一个`datetime.timedelta`对象

> session还是不能存储密码等敏感信息，因为即使不知道密钥还是可以被某些工具破解session内容。



## Flask上下文

Flask的两种上下文：

- **程序上下文**（application context）：存储程序运行所必须的信息
- **请求上下文**（request context）：存储请求的各种信息，如请求的URL，HTTP方法等。比如session，request对象等。

### 上下文全局变量

Flask将请求报文封装在**request**对象里，使用的时候并不需要传递这个参数。

> 正常情况下，视图函数使用request前必须要给函数传入这个对象，这样会造成大量没有必要的重复。

大概原理：

> Flask 会在每个请求产生后自动激活当前请求的上下文，激活请求上下文后， request 被临时设为全局可访问 而当每个请求结束后， Flask 就销毁对应的请求上下文。

多线程的情况下，Flask通过本地线程（thread local）技术将请求对象在特定的线程和请求中全局可访问。

> 像`response`对象这样好用的上下文全局变量，Flask一共提供了四个

| 变量名      | 类型       | 说明                                                         |
| ----------- | ---------- | ------------------------------------------------------------ |
| current_app | 程序上下文 | 指向处理请求的当前程序实例                                   |
| g           | 程序上下文 | 替代python的全局变量用法，确保仅在当前请求中可用。用于存储全局数据，每次其你去都会重设 |
| request     | 请求上下文 | 封装客户端发出的请求报文数据                                 |
| session     | 请求上下文 | 用于存储请求之间的数据，通过Cookie实现。                     |

### 激活上下文

以下情况Flask会自动激活**程序上下文**

- `flask run`启动程序时
- `app.run()` 启动程序时
- 执行使用 `@app.cli.command()` 装饰器注册的flask命令时
- 使用 `flask shell` 启动 python shell时

当请求进入时， Flask 会自动激活**请求上下文**，这时我们可以使用 request session 变量。

请求上下文被激活时，程序上下文也被自动激活 当请求处理完毕后，请求上下文和程序上下文也会自动销毁。

> `url_for()`和`jsonify()`等函数也只能在视图函数中使用。

手动激活上下文，比如可以在一个普通的shell中

```python
from app import app
from flask import current_app

with app.app_context():
    print(current_app.name)
    
# 效果相同
app_context = app.app_context()
app_context.push()  # 激活上下文
print(current_app.name)

app_context.pop()  # 退出上下文
```

```
app
```

创建请求上下文

```python
with app.text_request_context('/hello'):
    print(request.method)
```

### 上下文钩子

`teardown_appcontext`钩子，使用它注册的回调函数会在程序上下文被销毁时调用，而且通常也会在请求上下文被销毁时调用。

比如你需要在每个请求处理结束后销毁数据库连接：

```python
@app.teardonw_appcontext
def teardown_db(exception):
    db.close()
```

使用`app.teardown_appcontext`装饰器注册的回调函数需要接收异常对象作为参数， 当请求被正常处理时这个参数值将是 None ，这个函数的返回值将被忽略。

## HTTP进阶实践

> 进阶实践就表示初学可以不见。

### 重定向回上一个页面

浏览某个文章时，需要登录才能查看全文。登录后自动跳回文章页面

#### 1.获取上一个页面的URL

两种方式

```python
request.referrer
```

或在URL中手动加入一个新的参数，一般用`next`命名

例如

```python
@app.route('/foo')
def foo():
    return url_for('do_something', next=request.full_path)

@app.route('/bar')
def bar():
    return url_for('do_something', next=request.full_path)
```

然后在do_something视图内获取next

```python
return redirect(request.args.get('next'))
```

为了避免为空，也要添加备选项

```python
return redirect(request.args.get('next'), url_for('hello'))
```

两种方法的结合，封装一个新的函数

```python
def redirect_back(default='hello', **kwargs):
    for target in request.args.get('next'), request.referrer:
        if target:
            return redirect(target)
    return redirect(url_for(default, **kwargs))
```

这时，只需要

```python
return redirect_back()
```

#### 2.对URL进行安全验证

referer和next很容易被篡改，如果不对这些值进行验证，会形成开放重定向（open redirect）漏洞。

比如：如果访问下面的URL

http://localhost:5000/do-something?next=http://badsite.com

你就会重定向到http://badsite.com这个网站，而这个网站如果是钓鱼网站，就有可能盗取你的账号密码。

验证URL安全性的例子

```python
from urllib.parse import urlparse, urljoin
from flask import request

def is_safe_url(target):
    ref_url = urlparse(request.host_url)
    test_url = urlparse(urljoin(request.host_url, target))
    return test_url.scheme in ('http', 'https') and \
        ref_url.netloc == test.url.netloc
```



该函数接收目标URL为参数，并通过`request.host_url`获取程序内的主机URL，然后用`urljoin()`将目标URL转换为绝对URL。接着，分别使用 urlparse 模块提供的 urlparse()函数解析两个 URL，最后对目标 URL 的URL 模式和主机地址进行验证，确保只有属于程序内部的 URL 才会被返回。

之后，先验证重定向网站，再返回

```python
def redirect_back(default='hello', **kwargs):
    for target in request.args.get('next'), request.referrer:
        if not target:
            continue
        if is_safe_url(target):
            return redirect(target)
    return redirect(url_for(default, **kwargs))
```

### 使用AJAX技术发送异步请求

AJAX基于XMLHttpRequest(https://xhr.spec.whatwg.org/)，实现不重载页面的情况下和服务器进行数据交换。

收到响应数据后局部更新页面。

具体的jquery代码部分略

简单来说，在flask服务端的操作很简单，只需要如常，或返回json数据即可。

```python
@app.route('/add_user/<int:user_id>')
def add_user(user_id):
    ...
    return jsonify(username=username, user_id=user_id)
```

### HTTP服务器端推送

经典例子聊天室，群A里有甲乙丙三人，甲发言，传到服务器，服务器需要向乙和丙推送新消息。

常用的服务器端推送（HTTP Server Push）技术如下：

| 名称                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 传统轮询                | 特定时间间隔内，客户端使用AJAX技术不断向服务器发起HTTP请求，然后获取新的数据并更新页面 |
| 长轮询                  | 和传统轮询类似，但是如果服务器端没有返回数据，那就保持连接一直开启，直到有数据时才返回。取回数据后再次发送另一个请求 |
| Server-Sent Events(SSE) | SSE通过HTML5中的EventSource API实现。SSE会在客户端和服务器端建立一个单向通道，客户端监听来自服务器端的数据，而服务器端可以在任意时间发送数据，两者建立类似订阅/发布的通信模式 |

除此之外，还有WebSocket协议，实时性更强，可以实现双向通信。

这篇文章有这几种方式的详细说明:https://stackoverflow.com/a/12855533/5511849

### Web安全防范

SQL注入、XSS攻击（cross-site scripting）、CSRF攻击等

这些将来需要好好了解

# 模板

https://jinja.palletsprojects.com/en/3.0.x/templates/

http://jinja.pocoo.org/docs/2.10/templates/#for

## 模板基本用法

模板中可以用特定的定界符标记 Jinja2 的语句和变量，有三种常用定界符：

- `{{ ... }}` 变量。
- `{% ... %}` 条件控制语句，如 if、for。
- `{# ... #}` 注释。



### 变量

模板支持用`.`的方式调用python字典的键值，例如python数据如下：

```python
user = {
    'name': 'Light',
    'teacher': True
}
```

使用模板

```jinja2
<title>{{ user.name }}</title>
```

### if语句

下面的代码展示了对教师和学生不同的显示方式

```jinja2
{% if user.teacher %}
    <h1>TEACHER: {{ user.name }}</h1>
{% else %}
    <h1>STUDENT: {{ user.name }}</h1>
{% endif %}
```



### for语句

例如，创建了一个python对象如下

```python
students = [
    {'name': 'Lucy', 'age': 22},
    {'name': 'David', 'age': 19},
    {'name': 'Lily', 'age': 21},
]
```

采用如下语句遍历`students`

```jinja2
<ul>
    {% for stu in students %}  {# 迭代 movies 变量 #}
    <li>{{ stu.name }} - {{ stu.age }}</li> 
    {% endfor %}  {# 使用 endfor 标签结束 for 语句 #}
</ul>
```



### 循环特殊变量

常用的for循环特殊变量

| 变量名           | 说明                         |
| ---------------- | ---------------------------- |
| `loop.index`     | 当前迭代数（从1开始）        |
| `loop.index0`    | 当前迭代数（从0开始）        |
| `loop.revindex`  | 当前反向迭代数（从1开始）    |
| `loop.revindex0` | 当前反向迭代数（从0开始）    |
| `loop.first`     | 如果是第一个元素，则为True   |
| `loop.last`      | 如果是最后一个元素，则为True |
| `loop.previtem`  | 上一个迭代的条目             |
| `loop.nextitem`  | 下一个迭代的条目             |
| `loop.length`    | 序列包含的元素数量           |

直接在循环体内使用即可，比如

```jinja2
{% for stu in students %}
    <li>{{ stu.name }} - {{ stu.age }}</li>
    {% if loop.last %}
        <p> {{ loop.nextitem.name }} </p>
    {% endif %}
{% endfor %}
```



> 提示
>
> * 使用 [Faker](https://github.com/joke2k/faker) 可以实现自动生成虚拟数据，它支持丰富的数据类型，比如时间、人名、地名、随机字符等。
> * 除了过滤器，Jinja2 还在模板中提供了一些测试器、全局函数可以使用；除此之外，还有更丰富的控制结构支持，有一些我们会在后面学习到，更多的内容则可以访问 [Jinja2 文档](http://jinja.pocoo.org/docs/2.10/templates/)学习。

### flask中使用模板

使用渲染函数`render_template()`

```python
from flask import Flask, render_template
user = {
    'name': 'Light',
    'teacher': True
}

students = [
    {'name': 'Lucy', 'age': 22},
    {'name': 'David', 'age': 19},
    {'name': 'Lily', 'age': 21},
]
@app.route('/students')
def student():
    return render_template('students.html', students=students, user=user)
```

在templates文件夹下创建`students.html`

```jinja2
{% if user.teacher %}
    <h1>TEACHER: {{ user.name }}</h1>
{% else %}
    <h1>STUDENT: {{ user.name }}</h1>
{% endif %}

<p> 一共有{{ students|length }}个学生 </p>
<ul>
    {% for stu in students %}  {# 迭代 movies 变量 #}
    <li>{{ loop.index }} {{ stu.name }} - {{ stu.age }}</li> 
    {% endfor %}  {# 使用 endfor 标签结束 for 语句 #}
</ul>
```

注：竖线是过滤器，可以调用python对象的属性，后面会详细介绍

`{{ students|length }} `就相当于`len(students)`



## 模板辅助工具

### 自定义模板变量

将变量定义为数据

```jinja2
{% set name = 'Lucy' %}

{# 使用该变量 #}
<h1> {{ name }} </h1>
```

将变量定义为模板数据，需要用endset标签声明结束。

```jinja2
{% set hello %}
    <p> hello </p>
    <p> world! </p>
{% endset %}

{# 使用该变量 #}
{{ hello }}
```

### 内置上下文变量

| 变量    | 说明                 |
| ------- | -------------------- |
| config  | 当前配置对象         |
| request | 当前请求对象         |
| session | 当前会话对象         |
| g       | 与请求绑定的全局变量 |

### 自定义上下文

作用：如果多个模板都要使用同一个变量

模板上下文处理函数：统一传入变量

```python
@app.context_processor
def inject_foo():
    return dict(name='Lucy', age='22')
```

调用`render_template()`函数渲染任何模板时，所有使用`app.context_processor`装饰注册的模板上下文处理函数都会被执行。

> 每次调用视图函数，都会调用。injuect_foo，并把数据传到模板内。

在模板中可以直接使用name、age变量。

### jinja内置全局函数

https://jinja.palletsprojects.com/en/3.1.x/templates/#list-of-global-functions

常用

**range**

同python

```jinja2
<ul>
    {% for i in range(1, 10, 2) %}
    <li>{{ i }}</li>
    {% endfor %}
</ul>
```

**生成随机文本**

默认生成5段文本，每段包含20~100个单词

```jinja2
{{ lipsum(n=5, html=True, min=20, max=100) }}
```

**dict函数**

同python

```jinja
{% set user=dict(name='lily', age=22) %}

<h1> {{ user.name }} - {{ user.age }} </h1>
```



### flask内置全局函数

生成URL，需要主程序中定义了相应的端点

```jinja2
{{ url_for('student') }}
```

用于获取flash消息

```jinja2
{{ get_flashed_messages() }}
```

### 自定义全局函数

两种方法

```python
# 方式1
@app.template_global()
def get_name():
    return 'lily'

# 方式2
@app.context_processor
def global_func():
    def get_name():
        return 'lily2'
    return {'get_name2':get_name}
```

模板中

```jinja2
<h1> get_name: {{ get_name() }} </h1>

<h1> get_name2: {{ get_name2() }} </h1>
```

### 过滤器的用法

过滤器的两种用法

用法1：竖线连接`|`

```jinja2
{{ name|upper }}
```

相当于`name.upper()`

用法2：用于一部分模板数据

```jinja2
{% filter upper %}
    hello world
{% endfilter %}
```

会把filter包裹的文字转换为大写

### 内置过滤器

| 过滤器                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `default(value, default_value=u'', boolean=False)`           | 设置默认值，默认值作为参数传入，别名为d                      |
| `escape(s)`                                                  | 转义HTML文本，别名为e                                        |
| `first(seq)`                                                 | 返回序列的第一个元素                                         |
| `last(seq)`                                                  | 返回序列的最后一个元素                                       |
| `length(object)`                                             | 返回变量长度                                                 |
| `random(seq)`                                                | 返回序列中的随机元素                                         |
| `save(value)`                                                | 将变量值标记为安全，避免转义，意味着可以直接嵌入标签。用Markup也能达到同样的效果。 |
| `trim(value)`                                                | 清除变量值前后的空格                                         |
| `max(value, case_sensitive=False, attribute=None)`           | 返回序列中的最大值                                           |
| `min(value, case_sensitive=False, attribute=None)`           | 返回序列中的最小值                                           |
| `unique(value, case_sensitive=False, attribute=None)`        | 返回序列中的不重复的值                                       |
| `striptags(value)`                                           | 清除变量值内的HTML标签                                       |
| `urlize(value, trim_url_limt=None, nofollow=False, target=None, rel=None)` | 将URL文本转换为可点击的HTML链接                              |
| `wordcount(s)`                                               | 计算单词数量                                                 |
| `tojson(value, indent=None)`                                 | 将变量值转换为JSON格式                                       |
| `truncate(s, length=255, killwords=False, end=‘...’, leeway=None)` | 截断字符串，常用于显示文章摘要，lenght参数设置截断的长度，killwords参数设置是否截断单词，end参数设置结尾的符号。 |

使用方法

```jinja2
<h1>hello, {{name|default('陌生人') }} </h1>
```

如果name不存在就用默认值

### 自定义过滤器

```python
@app.template_filter()
def double_length(s):
    return len(s) * 2
```

模板中

```jinja2
{% set word='hello' %}
<h1>word: {{ word }}</h1>
<h1>double length: {{ word|double_length }}</h1>
```

### 测试器

用于判断变量或表达式是True还是False

比如

```jinja2
{# {% set age=22 %} #}
{% set age='adf' %}

{% if age is number %}
    {{ age + 1}}
{% else %}
    无效的数字
{% endif %}
```

内置测试器如下

| 测试器               | 说明                                  |
| -------------------- | ------------------------------------- |
| callable(object)     | 判断对象是否可被调用                  |
| defined(value)       | 判断变量是否已定义                    |
| undefined(value)     | 判断变量是否未定义                    |
| none(value)          | 判断变量是否为None                    |
| number(value)        | 判断变量是否是数字                    |
| sequence(value)      | 判断变量是否是序列                    |
| string(value)        | 判断变量是否是字符串                  |
| iterable(value)      | 判断变量是否可迭代                    |
| mapping(value)       | 判断变量是否是匹配对象，比如字典      |
| sameas(value, other) | 判断变量是否与other指向相同的内存地址 |



samas使用方式如下：

```jinja
{% if foo is sameas(bar) %}
```

自定义测试器

```python
@app.template_test()
def good(score):
    if score >= 90:
        return True
    return False
```

模板文件中

```jinja2
{% set score=97 %}

{% if score is good %}
    <h1>Good</h1>
{% else %}
    <h1>加油!</h1>
{% endif %}
```

### 模板环境对象

用途：控制模板渲染的方方面面

比如：

可以通过修改模板环境对象来修改**定界符**

```python
app = Flask(__name__)
app.jinja_env.variable_start_string = '[['
app.jinja_env.variable_end_string = ']]'
```

可以直接添加自定义全局对象

```python
def hello():
    return 'hello world'
name = 'lily'

app.jinja_env.globals['hello'] = hello
app.jinja_env.globals['name'] = 'lily'
```

直接添加自定义过滤器

```python
def double_length(s):
    return len(s) * 2

app.jinja_env.filters['double_length'] = double_length
```

直接添加自定义测试器

```python
def good(score):
    if score >= 90:
        return True
    return False

app.jinja_env.tests['good'] = good
```

> 参考文档：https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Environment

## 模板结构组织

作用：减少重复代码

### 局部模板

作用：只包含部分代码，通常用于嵌入到其他模板内。

比如，可以制作一个顶部提示条局部模板`_banner.html`。在各个页面都展示

引入：

```jinja
{% include '_banner.html' %}
```

### 宏

作用：把一部分模板代码封装到宏内，通过传递不同的参数可以构建不同的内容。

通常命名为`macros.html`或`_macros.html`

示例：

```jinja2
{# macros.html #}
{% macro qux(amount=1) %}
    {% if amount == 1 %}
        I am qux.
    {% elif amount > 1 %}
        We are quxs.
    {% endif %}
{% endmacro %}
```

使用时

```jinja2
{% from 'macros.html' import qux %}
{{ qux{amount=5} }}
```

### include 与 import的区别

> 暂时没看懂

另外，在使用宏时我们需要注意上下文问题。在Jinja2 中，出于性能的考虑，并且为了让这一切保持显式，默认情况下包含（include）一个局部模板会传递当前上下文到局部模板中，但导入（ import ）却不会。具体来说，当我们使用render_template()函数渲染一个foo.html 模板时，
这个foo.html 的模板上下文中包含下列对象：

- Flask 使用内置的模板上下文处理函数提供的g、session、config、request。

- 扩展使用内置的模板上下文处理函数提供的变量。

- 自定义模板上下文处理器传入的变量。

- 使用render_template()函数传入的变量。

- Jinja2 和Flask内置及自定义全局对象。

- Jinja2 内置及自定义过滤器。

- Jinja2 内置及自定义测试器。

使用include 标签插入的局部模板（ 比如＿banner.html ）同样可以使用上述上下文中的变量和函数。而导人另一个并非被直接渲染的模板（比如macros.html ）时，这个模板仅包含下列这些对象：

- Jinja2 和Fla s k 内置的全局函数和自定义全局函数。
- Jinja2 内置及自定义过滤器。
- Jinja2 内置及自定义测试器。



因此，如果我们想在导人的宏中使用第一个列表中的2 、3、4 项，就需要在导入时显式地使用with context 声明传入当前模板的上下文：
```jinja2
{% from "macros.html" import foo with context %}
```

## 模板继承

通常定义一个基模板`base.html`，把网页上的导航栏、页脚等通用内容放到里面。

子模板就不需要管这些通用内容了。结构如下

基模板

```jinja2
{# 基模板固定内容 #}
{% block content %}
{% endblock %}
{# 基模板固定内容 #}
```

子模板

```jinja2
{% extends 'base.html' %}
{% block content %}
{# 子模板内容 #}
{% endblock %}
```

块的结束条件也可以使用块名

```jinja2
{% block body %}
...
{% endblock body %}
```

#### 编写基模板

```jinja2
<!DOCTYPE html>
<html>
<head>
    {% block head %}
        <meta charset="utf-8">
        <title>{% block title %}Template - HelloFlask{% endblock %}</title>
        <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
        {% block styles %}
            <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css' ) }}">
        {% endblock %}
    {% endblock %}
</head>
<body>
<nav>
    <ul><li><a href="{{ url_for('index') }}">Home</a></li></ul>
</nav>

<main>
    {% for message in get_flashed_messages() %}
        <div class="alert">{{ message }}</div>
    {% endfor %}
    {% block content %}{% endblock %}
</main>
<footer>
    {% block footer %}
        <small> &copy; 2018 <a href="http://greyli.com" title="Written by Grey Li">Grey Li</a> /
            <a href="https://github.com/greyli/helloflask" title="Fork me on GitHub">GitHub</a> /
            <a href="http://helloflask.com" title="A HelloFlask project">HelloFlask</a>
        </small>
    {% endblock %}
</footer>
{% block scripts %}{% endblock %}
</body>
</html>
```



里面定义了四个块

```jinja2
{% block head %}
{% block styles %}
{% block content %}
{% block footer %}
```

这些块的内容都可以重写

#### 编写子模板

可以看到，子模板就简洁了很多

注意：extends必须是子模板的第一个标签

```jinja2
{% extends 'base.html' %}
{% from 'macros.html' import qux %}

{% block content %}
{% set name='baz' %}
<h1>Template</h1>
<ul>
    <li><a href="{{ url_for('watchlist') }}">Watchlist</a></li>
    <li>Filter: {{ foo|musical }}</li>
    <li>Global: {{ bar() }}</li>
    <li>Test: {% if name is baz %}I am baz.{% endif %}</li>
    <li>Macro: {{ qux(amount=1) }}</li>
    <li><a href="{{ url_for('watchlist_with_static') }}">Watchlist with image and styles.</a></li>
    <li><a href="{{ url_for('just_flash') }}">Flash something</a></li>
</ul>
{% endblock %}
```

**子模板覆盖**：默认情况下直接给块编写内容会覆盖父模板的内容

**子模板追加**：使用`super()`函数可以父模板块已有的基础上追加内容，比如

```jinja2
{% block styles %}
{{ super() }}
...
{% endblock styles %}
```

## 模板进阶实践

### 加载静态文件

静态文件可以用`url_for()`函数来获取URL，默认端点值为`static`。

默认的URL匹配规则为

```
/static/<path:filename>
```

`filename`是相对于static文件夹根目录的文件路径

比如

```jinja2
<img src="{{ url_for('static', filename='avatar.jpg') }}">
```

通常使用css框架来快速美化页面。

比如Bootstrap (http://getbootstrap.com)

使用宏来快速切换本地资源/CDN资源

```jinja2
{% macro static_file(type, filename_or_url, local=True) %}
    {% if local -%}
        {% set filename_or_url = url_for('static', filename=filename_or_url) %}
    {%- endif %}
    {% if type == 'css' -%}
        <link rel="stylesheet" href="{{ filename_or_url }}" type="text/css">
    {%- elif type == 'js' -%}
        <script type="text/javascript" src="{{ filename_or_url }}"></script>
    {%- elif type == 'icon' -%}
        <link rel="icon" href="{{ filename_or_url }}">
    {%- endif %}
{% endmacro %}
```

### 消息闪现

作用：比如在用户登录成功后显示“欢迎回来”

实现方式：在session中存储flask()函数存储的消息，然后在**模板**中使用`get_flashed_messages()`显示出来。

案例

```python
@app.route('/flash')
def just_flash():
    flash('welcome!')
    return redirect(url_for('index'))
```

在模板内

```jinja2
<main>
    {% for msg in get_flashed_messages() %}
        <div class="alert">{{ msg }}</div>
    {% endfor %}
</main>
```

> 注意：flash展示的格式还要由css文件来设置

当`get_flashed_message()`函数被调用时，session中存储的所有消息都会被移除。再刷新页面后不再出现这条消息。

使用bootstrap的写法

```html
{% for message in get_flashed_messages() %}
    <div class="alert alert-info">
        <button type="button" class="close" data-dismiss="alert">&times;</button>
        {{ message }}
    </div>
{% endfor %}
```



### 自定义错误页面

可以自己编写一个`404.html`文件

# 表单

python有个非常好用的表单库——`WTForms`

参考资料

- `WTForms`
  - 主页：https://github.com/wtforms/wtforms
  - 文档：https://wtforms.readthedocs.io/en/latest
- `Flask-WTF`
  - 主页：https://github.com/lepture/flask-wtf
  - 文档：https://flask-wtf.readthedocs.io/en/latest/
- `Flask-CKEditor`
  - 主页：https://github.com/greyli/flask-ckeditor
  - 文档：https://flask-ckeditor.readthedocs.io/

## HTML表单介绍

[表单参考](../../../前端/1.HTML/6.表单标签.md)

下面这个就是一个表单

```html
<form action="https://www.baidu.com/s" method="get">
    <input type="text" name="wd"/> <br>
    <input type="submit" value="搜索一下"/>
</form>
```

![image-20221028094158615](images/表单基础.png)

点击搜索一下，会跳转到：https://www.baidu.com/s?wd=Flask

常见属性的解释：

- `action`：提交表单后跳转的页面`action="#"`则表示提交给当前页面
- `method`：表单以何种请求方式提交
- `name`：通常用在input标签中，会拼接到URL链接的末尾
- `type`：通常用在input标签中，可以改变`type`来切换不同的控件

## Flask-WTF

```
pip install flask-wtf
```

使用前需要定义`secret_key`

```python
app.secret_key = 'abc123'
```





### WTForms表单类

```python
from flask_wtf import FlaskForm
# from wtforms import Form
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
    remember = BooleanField('Remember me')
    submit = SubmitField('Log in')
```

> 一般在flask中，直接继承FlaskForm类，要测试的话可以继承wtforms.Form类。

常用的WTForms字段

| 字段类              | 说明                            | 对应的HTML                                    |
| ------------------- | ------------------------------- | --------------------------------------------- |
| StringField         | 文本字段                        | `<input type="text">`                         |
| DateField           | 文本字段，值为datetime.date     | `<input type="text">`                         |
| DateTimeField       | 文本字段，值为datetime.datetime | `<input type="text">`                         |
| FloatField          | 浮点数字段，值为float           | `<input type="text">`                         |
| IntegerField        | 整数字段，值为int               | `<input type="text">`                         |
| FileField           | 文件上传字段                    | `<input type="file">`                         |
| BooleanField        | 复选框，值为True/False          | `<input type="checkbox">`                     |
| RadioField          | 单选按钮                        | `<input type="radio">`                        |
| SelectField         | 下拉列表                        | `<select><opiton></option></select>`          |
| SelectMultipleField | 多选下拉列表                    | `<select multiple><opiton></option></select>` |
| SubmitField         | 提交按钮                        | `<input type="submit">`                       |
| HiddenField         | 隐藏文本字段                    | `<input type="hidden">`                       |
| PasswordField       | 密码文本字段                    | `<input type="password">`                     |
| TextAreaField       | 多行文本字段                    | `<textarea></textarea>`                       |

字段类构造方法常用参数

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| label      | 字段标签`<label>`的值，渲染后显示在输入字段前的值            |
| render_kw  | 字典，用于设置`<input>`标签的属性。如传入`{'placeholder': 'input name'}`，则`<input>`标签对应的`placeholder`属性为`input name` |
| validators | 一个列表，包含一系列验证器，会在表单提交后被逐一调用以验证表单数据 |
| default    | 字符串或可调用对象，用来为表单字段设置默认值                 |

常用的WTForms验证器

| 验证器                                                | 说明                           |
| ----------------------------------------------------- | ------------------------------ |
| `DataRequired(message=None)`                          | 验证数据是否有效               |
| `Email(message=None)`                                 | 验证Email地址                  |
| `EqualTo(fieldname, message=None)`                    | 验证两个字段值是否相同         |
| `InputRequired(message=None)`                         | 验证是否有数据                 |
| `Length(min=-1, max=-1, message=None)`                | 验证输入值长度是否在给定范围内 |
| `NumberRange(min=None, max=None, message=None)`       | 验证输入数字是否在给定范围内   |
| `Optional(strip_whitespace=True)`                     | 允许输入值为空，并跳过其他验证 |
| `Regexp(regex, flags=0, message=None)`                | 使用正则表达式验证输入值       |
| `URL(require_tld=True, message=None)`                 | 验证URL                        |
| `AnyOf(values, message=None, values_formatter=None)`  | 确保输入值在可选值列表中       |
| `NoneOf(values, message=None, values_formatter=None)` | 确保输入值不在可选列表中       |

> 其中，message参数是自定义错误消息文本，若没有设置则使用默认的英文错误消息

### 输出HTML代码

input元素

```python
form = LoginForm()
print(form.username())
```

```
<input id="username" name="username" required type="text" value="">
```

label元素

```python
print(form.username().label())
```

```
<label for="username">Username</label>
```

一般情况下还需要添加额外的属性，比如`class`属性来指定特定的css样式，或者`placeholder`属性来显示提示输入文本。

添加额外属性的方式有以下2种

1.使用`render_kw`属性

```python
username = StringField('Username', render_kw={'placeholder': 'your name'})
```

2.调用字段时传入

```python
print(form.username(class_='username'))
```

```
<input class="username" id="username" name="username" required type="text" value="">
```

### 在模板中渲染表单

方式：把表单类实例传入模板。

```python
from forms import LoginForm

@app.route('/')
def index():
    form = LoginForm()
    return render_template('index.html', form=form)
```

在模板中

```jinja2
<form method="post">
    {{ form.csrf_token }} <!-- 渲染CSRF令牌隐藏字段 -->
    {{ form.username.label }} {{ form.username }} <br>
    {{ form.password.label }} {{ form.password }} <br>
    {{ form.remember }} {{ form.remember.label }} <br>
    {{ form.submit }}<br>
</form>
```

> `form.csrf_token`是Flask-WTF为表单类自动创建的CSSRF令牌字段。

![image-20221028135354716](images/flask应用wtform.png)

### 应用Bootstrap的表单

bootstrap下载地址:https://v4.bootcss.com/docs/getting-started/download/

把里面的` bootstrap.min.css `复制到`./static/css/bootstrap.min.css`

然后编写代码

```html
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/bootstrap.min.css') }}">
</head>
<body>
    <form method="post">
        {{ form.csrf_token }}
        <div class="form-group">
            {{ form.username.label }}
            {{ form.username(class='form-control') }}
        </div>
        <div class="form-group">
            {{ form.password.label }}
            {{ form.password(class='form-control') }}
        </div>
        <div class="form-check">
            {{ form.remember(class='form-check-input') }}
            {{ form.remember.label }}
        </div>
        {{ form.submit(class='btn btn-primary') }}
    </form>
</body>
```

![image-20221028140630156](images/渲染bootstrap表单.png)

## 表单数据处理

大致有以下步骤：

1. 解析请求，获取表单数据
2. 数据转换，例如勾选框的值转换为python的布尔值
3. 验证数据，同时验证CSRF令牌
4. 若验证未通过，生成错误信息并显示在模板中
5. 若验证通过，将数据保存至数据库或进一步处理

`Flask-WTF`和`WTForms`可以极大简化上述步骤。

![](./images/表单处理流程图.drawio.svg)

### 提交表单

当页面中的submit按钮被点击后，就会发送一个包含表单字段信息的请求给服务器。

HTML表单中控制提交行为的属性如下：

- `action`，默认为当前URL，表单提交时发送请求的目标URL。
- `method`，默认为GET，是提交表单的HTTP方法，GET或POST
- `enctype`，默认为`application/x-www-form-urlencoded`，表单数据的编码类型，当表单中包含文件上传字段时，需要设为`multipart/form-data`，还可以设为纯文本类型：`text/plain`

一般用POST提交表单

### 验证表单数据



例：注册时要求用户名必填，加入`required`属性来做限制：

```html
<input type="text" name="username" required>
```

用wtform加入`required`：

```jinja2
{{ form.username(required='') }}
```



WTForms主要通过传入`validators`对象来验证。

案例

```python
# from flask_wtf import FlaskForm
from wtforms import Form
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length

class LoginForm(Form):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
```

在python shell中执行

```
>>> form = LoginForm(username='', password='123')
>>> form.data  # 表单数据字典
{'username': '', 'password': '123'}
>>> form.validate()
False
>>> form.errors # 错误消息字典
{'username': ['This field is required.'], 'password': ['Field must be between 8 and 128 characters long.']}
```



> 在Flask中可以通过request.form获得请求对象的表单数据

在视图函数中验证表单

如果请求方式是GET，只是渲染该页面，如果是POST，则处理表单请求，比如保存到数据库之类的

```python
from flask import request

@app.route('/', methods=['GET', 'POST'])
def index():
    form = LoginForm()
    # 处理POST请求
    if request.method == 'POST' and form.validate():
        print(request.form)
        return f"username: {username} 登录成功！"
    # 处理GET请求
    return render_template('index.html', form=form)
```

可以用`Flask-WTF`提供的`validate_on_submit()`方法合并这两个操作

```python
@app.route('/', methods=['GET', 'POST'])
def index():
    form = LoginForm()
    if form.validate_on_submit():
        username = form.username.data
        return f"username: {username} 登录成功！"
    # 处理GET请求
    return render_template('index.html', form=form)
```

> 除了POST方法，PUT、PATCH、DELETE方法，`validate_on_submit()`也会验证表单数据

如果`form.validate_on_submit()`返回True，则可以在这个if语句内获取表单数据

> 由于提交表单后会发送POST请求，当F5刷新时，默认是发送上一个请求，这就会弹出一个询问用户是否要再次提交表单的确认窗口。
>
> 因此，处理表单后最好返回一个重定向响应，让浏览器重新发送一个新的GET请求
>
> 这被称为PRG模式（POST/Redirect/GET）

### 在模板中渲染错误消息

若`form.validate_on_submit()`返回False，WTForms会把错误消息添加到表单类的errors属性中。

可以用这个属性来返回错误信息

```jinja2
<form method="POST">
    {{ form.csrf_token }}
    {{ form.username_label }} <br>
    {{ form.username() }} <br>
    {% for msg in form.username.errors %}
        <small class="error">{{ message }}</small><br>
    {% endfor %}
    {{ form.password.label }}<br>
    {{ form.password }}<br>
    {% for msg in form.password.errors %}
        <small class="error">{{ message }}</small><br>
    {% endfor %}
    {{ form.remember }} {{ form.remember.label }} <br>
    {{ form.submit }}<br>
</form>
```

## 表单进阶实践

### 设置内置错误消息为中文

```python
from flask_wtf import FlaskForm

app = Flask(__name__)
app.config['WTF_I18N_ENABLED'] = False

class BaseForm(FlaskForm):
    class Meta:
        locales = ['zh']

class LoginForm(BaseForm):
    ...
```

### 使用宏渲染表单

作用：简化每个字段的重复定义工作

```jinja2
{% macro form_field(field) %}
    {{ field.label }} <br>
    {{ field(**kwargs) }} <br>
    {% if field.errors %}
        {% for error in field.errors %}
            <small class="error">{{ error }}</small> <br>
        {% endfor %}
    {% endif %}
{% endmacro %}
```

简化后的模板

```jinja2
{% from 'macros.html' import form_field %}

<form method="POST">
    {{ form.csrf_token }}
    {{ form_field(form.username) }} <br>
    {{ form_field(form.password) }} <br>
</form>
```

### 自定义验证器

行内验证器

```python
from wtforms import IntegerField, SubmitField
from wtforms.validators import ValidationError

class FortyTwoForm(FlaskForm):
    answer = IntegerField('The Number')
    submit = SubmitField()
    
    def validate_answer(form, field):
        if field.data != 42:
            raise ValidationError('Must be 42.')
```

注意：

- 表单类中`validate_字段属性名`命名的方法，在验证字段数据时会调用该方法，因此在命名方法时要注意。

全局验证器

可重用的通用验证器。

```python
from wtforms.validators import ValidationError
def is_42(form, field):
    if field.data != 42:
        raise ValidationError('Must be 42')
        
class FortyTwoForm(FlaskForm):
    answer = IntegerField('The Number', validators=[is_42])
    submit = SubmitField()
```

简单的验证函数就传两个参数就行

复制的验证函数需要用工厂函数实现

```python
from wtforms.validators import ValidationError

def is_42(message=None):
    if message is None:
        message = 'Must be 42.'
    
    def func(form, field):
        if field.data != 42:
            raise ValidationError(message)
    return func

class FortyTwoForm(FlaskForm):
    answer = IntegerField('The Number', validators=[is_42()])
    submit = SubmitField()
```



### 文件上传

HTML的文件上传标签如下

```html
<input type="file">
```

文件上传防范：

- 验证文件类型
- 验证文件大小
- 过滤文件名

#### 定义上传表单

```python
from flask_wtf.file import FileField, FileRequired, FileAllowed
class UploadForm(FlaskForm):
    photo = FileField('Upload Image', validators=[FileRequired(), FileAllowed(['jpg', 'png'])])
    submit = SubmitField()
```

也可以使用`accept`属性在客户端实现类型过滤，在打开的文件窗口会自动过滤掉accept之外的文件类型，但是用户还是可以选择其他类型的文件。

```html
<input type="file" id="profile_pic" name="profile_pic" accept=".jpg, .png"
```

文件大小限制，限制为文件大小最大为3m

```python
app.config['MAX_CONTENT_LENGTH'] = 3 * 1024 * 1024
```

#### 渲染上传表单

```python
@app.route('/upload', methods=['GET', 'POST'])
def upload():
    form = UploadForm()
    ...
    return render_template('upload.html', form=form)
```

模板

```jinja2
<form method="POST" enctype="multipart/form-data">
    {{ form.csrf_token }}
    {{ form_field(form.photo) }}
    {{ form.submit }}
</form>
```

> 如果不加enctype属性，浏览器只会把文件名作为表单数据提交

#### 处理上传文件

通过`request.file`获取上传文件。这个属性是`ImmutableMultiDict`字典对象。

```
ImmutableMultiDict([('photo', <FileStorage: u'xxx.jpg' ('image/jepg')>)])
```

获取文件对象

```python
request.files.get('photo')
```

使用Flask-WTF时，它会自动获取对应的文件对象，使用data属性即可获取文件对象。

```python
import os

app.config['UPLOAD_PATH'] = os.path.join(app.root_path, 'uploads')

@app.route('/upload', methods=['GET', 'POST'])
def upload():
    form = UploadForm()
    if form.validate_on_submit():
        f = form.photo.data
        filename = random_filename(f.filename)
        f.save(os.path.join(app.config['UPLOAD_PATH'], filename))
        flash('Upload success.')
        session['filenames'] = [filename]
        return redirect(url_for('show_images'))
    return render_template('upload.html', form=form)
```

三种文件名处理方式

为什么要处理：因为有人可能恶意修改文件名，比如`../../../home/xx/.bashrc`，如果表示上级路径的`..`数量正确，文件就会覆盖掉系统文件。

```python
# 1. 原文件名
filename = f.filename

# 2.使用过滤后的文件名
from werkzeug import secure_filename
# 过滤掉文件名中的非ASCII支付
secure_filename(f.filename)

# 统一重命名
def random_filename(filename):
    ext = os.path.splitext(filenmae)[1]
    new_name = uuid.uuid4().hex + ext
    return new_name
```

查看上传的文件

```python
from flask import send_from_directory
@app.route('/uploads/<path:filename>')
def get_file(filename):
    return send_from_directory(app.config['UPLOAD_PATH'], filename)
```

#### 多文件上传

Flask-WTF(0.14.2)未添加多文件上传的渲染和验证支持，因此需要手动操作。

使用multiple属性开启多文件上传选项

```html
<input type="file" id="file" name="file" multiple>
```

表单类创建

```python
from wtforms import MultipleFileField
class MultiUploadForm(FlaskForm):
    photo = MultipleFileField('Upload Image', validators=[DataRequired()])
    submit = SubmitField()
```

使用`request.files.getlist()`获取所有上传文件对象的列表。

```python

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

@app.route('/multi-upload', methods=['GET', 'POST'])
def multi_upload():
    form = MultiUploadForm()

    if request.method == 'POST':
        filenames = []

        # check csrf token
        try:
            validate_csrf(form.csrf_token.data)
        except ValidationError:
            flash('CSRF token error.')
            return redirect(url_for('multi_upload'))

        photos = request.files.getlist('photo')
        # check if user has selected files. If not, the browser
        # will submit an empty file part without filename
        if not photos[0].filename:
            flash('No selected file.')
            return redirect(url_for('multi_upload'))

        for f in photos:
            # check the file extension
            if f and allowed_file(f.filename):
                filename = random_filename(f.filename)
                f.save(os.path.join(
                    app.config['UPLOAD_PATH'], filename
                ))
                filenames.append(filename)
            else:
                flash('Invalid file type.')
                return redirect(url_for('multi_upload'))
        flash('Upload success.')
        session['filenames'] = filenames
        return redirect(url_for('show_images'))
    return render_template('upload.html', form=form)
```

### Flask-CKEditor

文档：https://flask-ckeditor.readthedocs.io/en/latest/plugins.html

富文本编辑器，类似发帖的时候下面的一堆调整字体字号的功能。

[CKEditor](http://ckeditor.com/)就是一个开源的富文本编辑器。

```
pip install flask-ckeditor
```



加载CKEditor

```python
from flask_ckeditor import CKEditor
ckeditor = CKEditor(app)
```



#### 配置选项和说明

https://flask-ckeditor.readthedocs.io/en/latest/configuration.html

```python
# 设为True会使用内置的本地资源
CKEDITOR_SERVE_LOCAL = False

# CKEditor包类型，可选basic, standard, full
CKEDITOR_PKG_TYPE = 'standard'

# 界面语言，传入ISO639格式的语言码
CKEDITOR_LANGUAGE = ''

# 编辑器高度
CKEDITOR_HEIGHT = ''

# 编辑器宽度
CKEDITOR_WIDTH = ''

# 如何修改
app.config['CKEDITOR_SERVE_LOCAL'] = True
```

#### 渲染富文本编辑器

富文本编辑器表单模板

```python
from flask_ckeditor import CKEditorField
class RichTextForm(FlaskForm):
    title = StringField('Title', validators=[DataRequired(), Length(1, 50)])
    body = CKEditorField('Body', validators=[DataRequired()])
    submit = SubmitField('Publish')
```

模板

```jinja2
{% extends 'base.html' %}
{% from 'macros.html' import form_field %}

{% block content %}
    <h2>Integrate <a href="https://ckeditor.com">CKEditor</a> with <a href="https://github.com/greyli/flask-ckeditor">Flask-CKEditor</a>
    </h2>
    <form method="post">
        {{ form.csrf_token }}
        {{ form_field(form.title) }}
        {{ form_field(form.body) }}
        {{ form.submit }}
    </form>
{% endblock %}

{% block scripts %}
    {{ super() }}
    {{ ckeditor.load() }}
    {{ ckeditor.config(name='body') }}
{% endblock %}

```

### 单个表单多个提交按钮

比如写文章时，一个按钮是发布，另一是保存为草稿

form定义如下

```python
class NewPostForm(FlaskForm):
    title = StringField('Title', validators=[DataRequired(), Length(1, 50)])
    body = TextAreaField('Body', validators=[DataRequired()])
    save = SubmitField('Save')
    publish = SubmitField('Publish')
```

哪个按钮被点击，`requst.form`字典就包含哪个按钮。

`form.<按钮名>`就是True或False

视图函数如下

```python
@app.route('/two-submits', methods=['GET', 'POST'])
def two_submits():
    form = NewPostForm()
    if form.validate_on_submit():
        if form.save.data:
            # save it...
            flash('You click the "Save" button.')
        elif form.publish.data:
            # publish it...
            flash('You click the "Publish" button.')
        return redirect(url_for('index'))
    return render_template('2submit.html', form=form)
```

### 单个页面多个表单

需要额外进行处理，区分提交字段，比如

```python
class SigninForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired(), Length(1, 20)])
    password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
    submit1 = SubmitField('Sign in')


class RegisterForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired(), Length(1, 20)])
    email = StringField('Email', validators=[DataRequired(), Email(), Length(1, 254)])
    password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
    submit2 = SubmitField('Register')
```

视图函数中

```python
@app.route('/multi-form', methods=['GET', 'POST'])
def multi_form():
    signin_form = SigninForm()
    register_form = RegisterForm()

    if signin_form.submit1.data and signin_form.validate():
        username = signin_form.username.data
        flash('%s, you just submit the Signin Form.' % username)
        return redirect(url_for('index'))

    if register_form.submit2.data and register_form.validate():
        username = register_form.username.data
        flash('%s, you just submit the Register Form.' % username)
        return redirect(url_for('index'))

    return render_template('2form.html', signin_form=signin_form, register_form=register_form)
```

模板中

```python
<form method="post">
    {{ signin_form.csrf_token }}
    {{ form_field(signin_form.username) }}
    {{ form_field(signin_form.password) }}
    {{ signin_form.submit1 }}
</form>
<h3>Register Form</h3>
<form method="post">
    {{ register_form.csrf_token }}
    {{ form_field(register_form.username) }}
    {{ form_field(register_form.email) }}
    {{ form_field(register_form.password) }}
    {{ register_form.submit2 }}
</form>
```



另一种更简介的方案是多视图处理

使用一个视图渲染

```python
@app.route('/multi-form-multi-view')
def multi_form_multi_view():
    signin_form = SigninForm2()
    register_form = RegisterForm2()
    return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)
```

另外两个视图处理

```python
@app.route('/handle-signin', methods=['POST'])
def handle_signin():
    signin_form = SigninForm2()
    register_form = RegisterForm2()

    if signin_form.validate_on_submit():
        username = signin_form.username.data
        flash('%s, you just submit the Signin Form.' % username)
        return redirect(url_for('index'))

    return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)


@app.route('/handle-register', methods=['POST'])
def handle_register():
    signin_form = SigninForm2()
    register_form = RegisterForm2()

    if register_form.validate_on_submit():
        username = register_form.username.data
        flash('%s, you just submit the Register Form.' % username)
        return redirect(url_for('index'))
    return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)
```

表单提交请求的目标URL通过action属性修改。

```jinja2
<h3>Login Form</h3>
<form method="post" action="{{ url_for('handle_signin') }}">
    {{ signin_form.csrf_token }}
    {{ form_field(signin_form.username) }}
    {{ form_field(signin_form.password) }}
    {{ signin_form.submit }}
</form>

<h3>Register Form</h3>
<form method="post" action="{{ url_for('handle_register') }}">
    {{ register_form.csrf_token }}
    {{ form_field(register_form.username) }}
    {{ form_field(register_form.email) }}
    {{ form_field(register_form.password) }}
    {{ register_form.submit }}
</form>
```

问题：如果验证未通过，需要将错误消息的form.errors字典传入入模板中。在处理表单的视图中传入表单错误信息，就意味着需要再次渲染模板，但是如果视图函数中还涉及大量要传人模板的变量操作， 那么这种方式会带来大量的重复。

对于这个问题，一般的解决方式是通过其他方式传递错误消息， 然后统一重定向到渲染表单页面的视图。比如，使用flash() 函数迭代form.errors 字典发送错误消息（ 这个字典包含字段名称与错误消息列表的映射），然后重定向到用来渲染表单的multi form multi v iew 视图。下面是一个使用flash()函数来发送表单错误消息的便利函数：

```python
def flash_errors(form):
    for field, errors in form.errors.items():
        for error in errors:
            flash(u"Error in the %s field - %s" % (
                getattr(form, field).label.text,
                error
            ))
```

如果你希望像往常一样在表单字段下渲染错误消息，可以直接将错误消息字典form.errors存储到se s s ion 中， 然后重定向到用来渲染表单的multi_form_multi_ view 视图。在模板中渲染表单字段错误时添加一个额外的判断，从session 中获取并迭代错误消息。

# 数据库
Flask涉及的相关python包

- SQLAlchemy
  - 主页：http://www.sqlalchemy.org/
  - 文档：http://docs.sqlalchemy.org/en/latest/
- Flask-SQLAlchemy
  - 主页：https://github.com/mitsuhiko/flask-sqlalchemy
  - 文档：https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/
- Alembic
  - 主页：https://bitbucket.org/zzzeek/alembic
  - 文档：http://alembic.zzzcoputing.com/en/latest/
- Flask-Migrate
  - 主页：https://github.com/miguelgrinberg/Flask-Migrate
  - 文档：https://flask-migrate.readthedocs.io/en/latest/


## Flask-SQLAlchemy

### 基本配置

安装

```
pip install flask-sqlalchemy
```

使用

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
db = SQLAlchemy(app)
```

常见的数据库URI格式

```python
# PostgreSQL
uri = 'postgresql://username:password@host/databasename'

# MySQL
uri = 'mysql://username:password@host/databasename'

# Oracle
uri = 'oracle://username:password@host:port/sidname'

# SQLite(UNIX)
uri = 'sqlite:////absolute/path/to/xx.db'

# SQLite(Windows)
uri = 'sqlite:///absolute\\path\\to\\xx.db'

# SQLite(内存)
uri = 'sqlite:///:memory:'
```

配置方式

```python
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///' + os.path.join(app.root_path, 'data.db'))
```

### 定义数据库模型

```python
class Note(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text)
```

常用字段

| 字段        | 说明                               |
| ----------- | ---------------------------------- |
| Integer     |                                    |
| String      | 字符串，可用参数length设置最大长度 |
| Text        | 较长的Unicode文本                  |
| Date        | datetime.date                      |
| Time        | datetime.time                      |
| DateTime    | datetime.datetime                  |
| Interval    | datetime.timedelta                 |
| Float       |                                    |
| Boolean     |                                    |
| PickleType  | 存储Pickle列化的Python对象         |
| LargeBinary | 存储任意二进制数据                 |

常用字段参数

| 参数名      | 说明                         |
| ----------- | ---------------------------- |
| primary_key | bool, 是否为主键             |
| unique      | bool, 是否不允许重复值       |
| index       | bool, 是否创建索引           |
| nullable    | bool, 默认True, 是否能为空值 |
| default     | 字段默认值                   |



字符串长度的约束标准

```
英文名 70
中文名 20
电子邮件 254
网址 255
用户名 36
```

默认情况下表名根据模型类名来转换

```
Message -> message
FooBar -> foo_bar
```

也可以定义`__tablename__`属性自定义表名。

### 创建数据库和表

在app.py内

```python
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)

app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv(
    'DATABASE_URL',
    'sqlite:///' + os.path.join(app.root_path, 'data.db')
)

db = SQLAlchemy(app)

class Note(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text)
```

使用flask shell进行测试

```
flask shell
```

```
>>> from app import db
>>> db.create_all()
>>> from sqlalchemy.schema import CreateTable
>>> print(CreateTable(Note.__table__))  

CREATE TABLE note (
        id INTEGER NOT NULL,
        body TEXT,
        PRIMARY KEY (id)
)


>>>
```

删除所有表

```
>>> db.drop_all()
```



也可以自定义flask命令创建数据库

```python
import click

@app.cli.command()
def initdb():
    db.create_all()
    click.echo('Initialized database.')
```

命令行下

```
flask initdb
```

## 数据库操作

以下操作在flask shell中进行

### 创建数据

```python
from app import db, Note
note1 = Note(body='hello1')
note2 = Note(body='hi')
note3 = Note(body='good')
db.session.add(note1)
db.session.add(note2)
db.session.add(note3)
db.session.commit()
```

这就创建并插入了3条数据

也可以使用`add_all()`一次添加所有对象

```python
add_all([note1, note2, note3])
```

### 查看数据

参考文档：http://docs.sqlalchemy.org/en/latest/orm/query.html

https://docs.sqlalchemy.org/en/20/orm/queryguide/query.html

常用查询方法

| 方法                  | 说明                                             |
| --------------------- | ------------------------------------------------ |
| all()                 | 查询所有                                         |
| first()               | 查询的第一条记录，不存在返回None                 |
| one()                 | 返回第一条记录，若记录数不为1，则报错            |
| get(ident)            | 返回指定主键值的记录，不存在返回None             |
| count()               | 返回查询结果的数量                               |
| one_or_none()         | 类似one()，如果结果数量不为1，返回None           |
| first_or_404()        | 返回第一条记录，不能存在返回404                  |
| get_or_404(ident)     |                                                  |
| paginate()            | 返回一个paination对象，可以对记录进行分页处理    |
| with_parent(instance) | 传入模型类实例作为参数，返回和这个实例相关的对象 |

查看所有数据

```python
Note.query.all()
```

```
[<Note 1>, <Note 2>, <Note 3>]
```

查看第一条数据

```python
Note.query.first()
```

```
<Note 1>
```

查看指定主键的数据

```python
Note.query.get(2)
```

```
<Note 2>
```

查看记录数量

```python
Note.query.count()
```

```
3
```

常用过滤方法

| 过滤器名称  | 说明                       |
| ----------- | -------------------------- |
| filter()    | 使用指定的规则过滤记录     |
| filter_by() | 以关键字表达形式           |
| order_by()  | 排序                       |
| limit(n)    | 限制返回记录数量           |
| group_by()  | 根据指定条件对记录进行分组 |
| offset(n)   | 偏移查询结果               |

```python
Note.query.filter(Note.body=='good').first()
```

```
<Note 3>
```

直接print可以查看对应的SQL

```python
print(Note.query.filter(Note.body=='good'))
```

```
SELECT note.id AS note_id, note.body AS note_body 
FROM note
WHERE note.body = ?
```

其他查询操作符

```python
# like
Note.query.filter(Note.body.like('%go%'))
# in
Note.query.filter(Note.body.in_(['a', 'good']))
# not in
Note.query.filter(~Note.body.in_(['a', 'good']))

# and (逗号分隔)
Note.query.filter(Note.body=='good', Note.body=='a')
# and (使用 sqlalchemy.and_)
from sqlalchemy import and_
Note.query.filter(and_(Note.body=='a', Note.body=='b'))
# and (叠加多个filter/filter_by)
Note.query.filter(Note.body=='good').filter(Note.body=='b')

# OR
from sqlalchemy import or_
Note.query.filter(or_(Note.body=='good', Note.body=='b'))
```

使用filter_by可以省略类名，比如

```python
Note.query.filter_by(body='good').first()
```

其他查询

```python
User.query.filter(User.username.startwith('zh'))
User.query.filter(User.username.contains('zh'))
User.query.filter(User.username.like('zh%'))
User.query.filter(User.username.ilike('zh%'))  # 忽略大小写
```

排序

```python
User.query.order_by()

# 也可以
User.query.order_by(User.age).all()
User.query.order_by(-User.age).all()  # 降序排列
```

限制

```python
User.query.order_by('id').limit(2).offset(2).all()
```

with_parent 查询

```python
school = School.query.get_or_404(school_id)
Student.query.with_parent(school).order_by(xx).paginate(page, per_page=per_page)
```





### 更新数据

```python
note = Note.query.get(2)
note.body = 'ok'
db.session.commit()
```

### 删除数据

```python
note = Note.query.get(1)
db.session.delete(note)
db.session.commit()
```

## 定义关系

### 配置shell上下文

```python
# app.py
@app.shell_context_processor
def make_shell_context():
    return dict(db=db, Note=Note)
```

这样，打开flask shell就能直接使用db和Note了。

```
>>> Note
<class 'app.Note'>
```

### 一对多

作者与文章

```python
class Author(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    # 定义关系属性
    articles = db.relationship('Article')
    

class Article(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(50), index=True)
    body = db.Column(db.Text)
    # 外键
    author_id = db.Column(db.Integer, db.ForeignKey('author.id'))
    author = db.relationship('Author', back_populates='articles')
```

一般在**多**的那边定义外键，在一的那边定义关系属性

在shell中演示如下

```python
tom = Author(name='tom')
a1 = Article(title='a1')
a2 = Article(title='a2')
db.session.add_all([tom, a1, a2])
db.session.commit()
# 建立关系
# 方式1，直接赋值
# a1.author_id = 1

# 方式2，操作关系属性
tom.articles.append(a1)
tom.articles.append(a2)
db.session.commit()
```

解除关系

```python
tom.articles.remove(a1)
db.session.commit()
```

也可以用`pop()`解除最后一个对象的关系

使用backref简化关系定义

```python
class Author(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(70), unique=True)
    phone = db.Column(db.String(20))
    # 定义关系属性
    articles = db.relationship('Article', backref='author')
class Article(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(50), index=True)
    body = db.Column(db.Text)
    # 外键
    author_id = db.Column(db.Integer, db.ForeignKey('author.id'))
    # author = db.relationship('Author', back_populates='articles')
```

可以省略一行，不过一般还是建议显示定义使用`back_populates`这样更便于理解

### 一对一

一个国家只有一个首都，一个首都对应一个国家

```python
class Country(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)
    capital = db.relationship('Capital', uselist=False)
    
class Capital(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)
    country_id = db.Column(db.Integer, db.ForeignKey('country.id'))
    country = db.relationship('Country')
```

设置`uselist=False`后，就只能存储单个记录了

```python
china = Country(name='China')
beijing = Capital(name='Beijing')
db.session.add(china)
db.session.add(beijing)
db.session.commit()

china.capital = beijing
db.session.commit()
```

### 多对多

学生与老师模型

需要创建一个关联表来表示多对多模型

```python
association_table = db.Table(
    'association', 
    db.Column('student_id', db.Integer, db.ForeignKey('student.id')),
    db.Column('teacher_id', db.Integer, db.ForeignKey('teacher.id'))
)

class Student(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)
    teachers = db.relationship('Teacher', secondary=association_table, back_populates='students')

class Teacher(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)
    students = db.relationship('Student', secondary=association_table, back_populates='teachers')
```



## 更新数据库表

### 删除后重建

```python
db.drop_all()
db.create_all()
```

命令实现

```python
@app.cli.command()
@click.option('--drop', is_flag=True, help='Creat after drop.')
def initdb(drop):
    if drop:
        click.confirm('this operation will delete the database, do you want to continue?', abort=True)
        db.drop_all()
        click.echo('drop tables.')
    db.create_all()
    click.echo('initialized databases.')
```

### 使用Flask-Migrate

http://alembic.zzzcomputing.com/en/latest/tutuorial.html

```
pip install flask-migrate
```

初始化

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

app = Flask(__name__)
db = SQLAlchemy(app)
migrate = Migrate(app, db)
```

创建迁移环境

这会在项目根目录下创建`migrations`文件夹

```
flask db init
```

生成迁移脚本

`-m`表示添加迁移备注信息

```
flask db migrate -m "add note timestamp"
```

更新数据库

```
flask db upgrade
```

回滚迁移

会撤销最后一次迁移在数据库中的改动

```
flask db downgrade
```



## 数据库进阶实践

### 级联操作

### 事件监听

SQLAlchemy提供了一个listen_for()装饰器，接收两个参数：

- target，监听对象，可以是模型类、类实例、类属性。
- identifier，被监听事件标识符，比如`set`、`append`、`remove`、`init_scalar`、`init_collection`等



比如下面这个草稿模型，每次修改正文以后，修改次数+1

```python
class Draft(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text)
    edit_count = db.Column(db.Integer, default=0)
```

编写事件监听函数

```python
# app.py
@db.event.listens_for(Draft.body, 'set')
def increment_edit_count(target, value, oldvalue, initiator):
    if target.edit_count is not None:
        target.edit_count += 1
```

- target：触发事件的模型类实例
- value：被设置的值
- oldvalue：被取代的旧值

# 电子邮件

## Flask-Mail

```
pip install flask-mail
```

初始化

```python
from flask_mail import Mail

app = Flask(__name__)
mail = Mail(app)
```

### 配置Flask-Mail

```python
# 用于发送右键的SMTP服务器
MAIL_SERVER = 'localhost'

MAIL_PORT = 25

# 是否使用STARTTLS
# MAIL_PORT = 587
MAIL_USE_TLS = False

# 是否使用SSL/TLS
# MAIL_PORT = 465
MAIL_USE_SSL = False

# 发信服务器的用户名
MAIL_USERNAME = None

# 发信服务器的密码
MAIL_PASSWORD = None

# 默认发信人
MAIL_DEFAULT_SENDER = None
```

常用电邮服务提供商的SMTP配置

```python
# Gmail
MAIL_SERVER = 'smtp.gmail.com'
MAIL_PASSWORD = '<邮箱密码>'

# qq
MAIL_SERVER = 'smtp.qq.com'
MAIL_PASSWORD = '<授权码>'

# 新浪
MAIL_SERVER = 'smtp.sina.com'
MAIL_PASSWORD = '<邮箱密码>'

# 163
MAIL_SERVER = 'smtp.163.com'
MAIL_PASSWORD = '<授权码>'

# outlook
MAIL_SERVER = 'smtp.office365.com'
MAIL_PASSWORD = '<邮箱密码>'
```

### 构建邮件数据

```python
from flask_mail import Message
from app import mail

message = Message(
    subject='Hello, world!',
    recipients=['Zorn <zorn@example.com>'],
    body='hello world'
)
```

### 发送邮件

```python
mail.send(message)
```

## 使用事务邮件服务SendGird

- Mailgun：https://www.mailgun.com/
- SendGrid：https://sendgrid.com/
