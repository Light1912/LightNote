# bluelog数据库

最近看到的一篇好文章：https://mp.weixin.qq.com/s/LvsHDIY9qTWF61Bt2CZaNg

首先先阅读一下代码，先解决我个人的几个问题。

## 数据库加载过程

使用flask_sqlalchemy时，导包的顺序有点乱，具体顺序是怎样的？

在bluelog项目中，首先阅读`__init__.py`，第一次用到数据库的代码应该出现在视图函数里。也就是这一行

```python
from bluelog.blueprints.admin import admin_bp
```

进入admin视图发现，是通过`extensions.py`加载数据库的

```python
# blueprints/admin.py
from bluelog.extensions import db
```

进入`extensions.py`，可以看到，代码通过这两行加载数据库

```python
# extensions.py
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()
```

回到`__init__.py`同样可以发现，这里的db也是通过`extensions.py`获得的。

接着就是数据库对象的相关定义，`models.py`脚本的工作就是完成表定义等一系列工作。

再回到`__init__.py`，可以看到，最后在`register_extensions()`函数中注册了数据库

```python
db.init_app(app)
```

**小结**

总体来说，db对象的经历就是

- 被定义：`db = SQLAlchemy()`
- 初始化：在`models.py`中初始化各个数据表
- 注册：`db.init_app(app)`



## db对象是同一个吗

在上面的过程中，我们可以看到，db对象在各个库中都有加载到，那每个包加载的db对象是同一个吗？其实是的，可以做如下测试

在任意空文件夹创建三个文件

```
|-tmp
  |-db.py
  |-views.py
  |-main.py
```

分别填入如下的代码

`db.py`：这个脚本文件创建了一个数据库对象，接下来这个对象会被其他两个脚本导入。

```python
class DataBase:
    def __init__(self):
        self.name = 'apple'
db = DataBase()
```

`views.py`：这个脚本导入了db对象，并且定义了一个函数，用于输出db对象的名称

```python
from db import db
def show_dbname():
    print("views.py db.name:", db.name)
```

`main.py`：首先加载views和db，然后展示db.name，修改db.name后再展示一次。

```python
from views import show_dbname
from db import db

show_dbname()

print('main.py change db.name...')
db.name = 'banana'

show_dbname()
```

最后运行`__init__.py`文件

```
python __init__.py
```

```
views.py db.name: apple
main.py change db.name...
views.py db.name: banana
```

可以看到，我们调用的是views里面的函数，但是是在`__init__.py`里修改db对象的名字，views里面的db也跟着一起发生改变了。

## bluelog数据库设计

首先思考一下数据库包含哪些表：

- 用户表Admin：因为是私人博客，所以只有管理员表
- 文章类别表Category：通过文章类别可以一次性索引该类别下的多篇文章。
- 文章表Post：存储文章标题正文等信息
- 评论表Comment：文章评论表。
- 扩展链接表Link：右侧导航栏上半部分的链接信息。

然后思考每个表的字段有哪些。

> 首先，每个表都应该有`id`这个主键。
>
> 然后个人认为两个通用的字段是“**创建时间**”和“**更新时间**”，不过这个项目只有文章表和评论表有**创建时间**字段。

![](images/bluelog_database.png)

## flask_sqlalchemy的使用

### 定义表和字段

```python
class MyTable(db.Model):
    # 整型字段
    id = db.Column(db.Integer, primary_key=True)
    # 字符串
    username = db.Column(db.String(20))
    # text
    content = db.Column(db.Text)
    # 布尔
    id_delete = db.Column(db.Boolean, default=False)
    # 时间戳
    create_time = db.Column(db.DateTime, default=datetime.utcnow, index=True)
```

### 一对多

文章与类别：每篇文章都会属于一个类别，一个类别下有多篇文章

```python
class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    category_id = db.Column(db.Integer, db.ForeignKey('category.id'))
    category = db.relationship('Category', back_populates='posts')
    
class Category(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    posts = db.relationship('Post', back_populates='category')
```

`_id`定义在**一**的那边。

`db.relationship`定义在**多**的那边

这样，就可以通过`Post.category`找到文章对应的类别，也可以通过`Category.posts`找到这个类别下的所有文章。

写法是成对的

```python
category = db.relationship('Category', back_populates='posts')
posts = db.relationship('Post', back_populates='category')
```

### 自己一对自己多

文章评论和评论回复关系。在文章下可以留下评论，同时这条评论也有可能被其他评论回复。

```python
class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    replied_id = db.Column(db.Integer, db.ForeignKey('comment.id'))
    replies = db.relationship('Comment', back_populates='replied', cascade='all, delete-orphan')
    replied = db.relationship('Comment', back_populates='replies', remote_side=[id])
```



replied_id就表示这条评论回复的评论的id

repiled表这条评论回复的评论

replies表示所有回复这条评论的评论



例：tom评论文章“very good”，lily评论tom的这条评论“I agree”，jack也评论道“Yes”

```python
tom_comment.id = 1
tom_comment.replies = [lily_comment, jack_comment]
tom_comment.replied = None  # 因为tom评论的是文章

lily_comment.id = 2
lily_comment.replied_id = 1
lily_comment.replied = tom_comment

jack_comment.id = 3
jack_comment.replied_id = 1
jack_comment.replied = tom_comment
```

### 创建单条数据

```python
category = Category(name='Default')
db.session.add(category)
db.session.commit()
```

### 创建多条数据

```python
twitter = Link(name='Twitter', url='#')
facebook = Link(name='Facebook', url='#')
linkedin = Link(name='LinkedIn', url='#')
google = Link(name='Google+', url='#')
db.session.add_all([twitter, facebook, linkedin, google])
db.session.commit()
```

### 获取数据

```python
Category.query.get(1)
Admin.query.first()

Category.query.filter_by(name=field.data).first()

Post.query.get_or_404(post_id)

# 获取并排序
Category.query.order_by(Category.name).all()
```

### 分页器

```python
Post.query.order_by(Post.timestamp.desc()).paginate(
        page, per_page=current_app.config['BLUELOG_MANAGE_POST_PER_PAGE'])

Post.query.with_parent(category).order_by(Post.timestamp.desc()).paginate(page, per_page)

Post.query.order_by(Post.timestamp.desc()).paginate(page, per_page=per_page)
```



调用`paginate`方法会返回一个`Pagination`类实例，包含分页信息。

`Pagination.items`以列表形式返回对应页的记录。

`Pagination`类属性

```python
pagination.items  # 当前页面的记录
pagination.page  # 当前页数
pagination.per_page  # 每页的记录数
pagination.pages  # 总页数
pagination.total  # 记录总数
pagination.next_num  # 下一页的页数
pagination.prev_num  # 上一页的页数
pagination.has_next  # 如果存在下一页，返回True
pagination.has_prev  # 如果存在上一页，返回True
pagination.query  # 分页的源查询
pagination.prev()  # 上一页的分页对象
pagination.next()  # 下一页的分页对象

# 迭代一个页数列表。
# left_edge 表示最左边的页数
# left_current 表示当前页数左边的页数
# right_edge 表示最右边的页数
# right_current 表示当前页数左边的页数
# 假设总共20页，默认设置迭代的页数列表为
# 1, 2, None, 8, 9, 10, 11, 12, 13, 14, 15, None, 19, 20
pagination.iter_pages(left_edge=2, left_current=2, right_current=5, right_edge=2)
```

