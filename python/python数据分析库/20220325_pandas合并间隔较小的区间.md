https://stackoverflow.com/questions/68358218/pandas-merging-start-end-time-ranges-with-short-gaps

```python
import numpy as np
import pandas as pd
df = pd.DataFrame([
    [ 2,  6],
    [ 7,  8],
    [12, 14],
    [18, 20],
    [24, 25],
    [26, 28],
    [29, 33],
    [35, 36],
    [39, 41],
    [44, 45],
    [48, 50],
    [53, 54],
    [58, 59],
    [62, 63],
    [65, 68]], columns=["start", "end"])
# 效果同上
# np.random.seed(1)
# df = pd.DataFrame(np.random.randint(1,5,30)
#                  .cumsum()
#                  .reshape(-1, 2), columns = ["start", "end"])

# 合并短间隔区间
def merge_short_interval(df, interval=1):
    """ 间隔小于 min_periods 的相邻区间会被合并 """
    g = df['start'].sub(df['end'].shift())
    df = df.groupby(g.gt(interval).cumsum()).agg({'start':'min', 'end':'max'})
    return df

merge_short_interval(df, interval=3)
```

```
 	start 	end
0 	2 	8
1 	12 	14
2 	18 	20
3 	24 	54
4 	58 	68
```



思路

- 计算当前开始时刻减上一结束时刻，得到两个时间范围的间隔。
- 然后根据时间间隔分组，间隔小于阈值的被分为同一组。
- 对于每组，求出时间范围的最小、最大值，作为合并后的新范围。



这个方法还能够合并重叠的区间，前提是要有序排列。

python 代码的形式

```python
def merge_short_gap(spans, min_gap):
    new_spans = [spans[0]]
    for start, end in spans[1:]:
        gap = start - new_spans[-1][1]
        if gap <= min_gap:
            new_spans[-1][1] = end
        else:
            new_spans.append([start, end])
    return new_spans
```

```python
# 合并短间隔区间
spans = [
    [2, 6], 
    [7, 8], 
    [12, 14],
    [18, 20], 
    [24, 25], 
    [26, 28], 
    [29, 33],
    [35, 36],
    [39, 41],
    [44, 45],
    [48, 50],
    [53, 54],
    [58, 59],
    [62, 63],
    [65, 68]]
merge_short_gap(spans, 3)
```

```
[[2, 8], [12, 14], [18, 20], [24, 54], [58, 68]]
```



