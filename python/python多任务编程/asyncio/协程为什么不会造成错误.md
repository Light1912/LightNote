https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824

一文中，对协程优势进行了描述：协程不需要多线程的锁机制，因为只有一个线程，也**不存在同时写变量冲突**，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

我个人的问题是，为何不存在同时写变量冲突？

下面用一个案例试图说明下。

首先是多线程的案例，这里使用了4个线程。

```python
import threading
import time


n = 1000
def func():
    global n
    while n > 0:
        time.sleep(0.000001)
        n = n - 1
        

threading.Thread(target=func).start()
threading.Thread(target=func).start()
threading.Thread(target=func).start()
threading.Thread(target=func).start()

time.sleep(.5)
print("最终n=", n)
```

最终结果往往是错误的：

```
最终n= -3
```



使用协程

```python
import asyncio
import time

n = 1000
async def func():
    global n
    while n > 0:
        await asyncio.sleep(0.000001)
        n = n - 1
        

async def main():
    tasks = [asyncio.create_task(func()) for _ in range(4)]
    await asyncio.gather(*tasks)

asyncio.run(main())
time.sleep(.5)
print("最终n=", n)
```

```
最终n= -3
```

然后我发现，关键是判断`n>0`到`n=n-1`之间不要切换协程。

也就是这一段代码得全部用同步代码，这样就不会造成错误了。

把中间的`sleep(0.000001)`

换成for循环，这样就能完美模拟了

```python
import threading
import time


n = 1000
def func(name):
    global n
    while n > 0:
        for _ in range(10000):
            continue
        n = n - 1
        print(name, n)
        

for name in range(4):
    threading.Thread(target=func, args=(name,)).start()


time.sleep(.5)
print("最终n=", n)
```

```
最终n= -3
```



协程

```python
import asyncio
import time

n = 1000
async def func(name):
    global n
    while n > 0:
        for _ in range(10000):
            continue
        print(name, n)
        n = n - 1
        

async def main():
    tasks = [asyncio.create_task(func(name)) for name in range(4)]
    await asyncio.gather(*tasks)

asyncio.run(main())
time.sleep(.5)
print("最终n=", n)
```

```
最终n= 0
```

## 总结

也就是说，协程可以自己控制什么时候切换协程。

对于一个协程函数，没有`await`的时候，代码是不会随意切换的。

比如对于下面这个代码段，协程是一直执行到底的。

```python
for _ in range(10000):
    continue
    n = n - 1
```

而对于线程，无法手动控制线程什么时候切换。在上面这个代码段中，就有可能在某次for循环中切换到另一个协程，这就造成错误了。



