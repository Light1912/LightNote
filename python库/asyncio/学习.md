# 异步编程

tornado、fastapi、django3 asgi、aiohttp等各种框架都在往异步的方向发展

如何讲解：

- 协程的概念
- asyncio模块进行异步编程
- 实战案例

## 协程

协程不是计算机提供的，是程序员人为创造的。

让一个线程在代码之间来回执行

协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现**代码块之间**相互切换进行。

如何实现：

- 第三方模块：greenlet，早期模块。
- yield关键字
- asyncio装饰器 (py3.4)
- async / await 关键字 (py3.5)【推荐】



### greenlet实现

```
pip install greenlet
```

例子：

```python
from greenlet import greenlet

def func1():
    print(1)
    gr2.switch()
    print(2)
    gr2.switch()
    
def func2():
    print(3)
    gr1.switch()
    print(4)
    
gr1 = greenlet(func1)
gr2 = greenlet(func2)

gr1.switch()
```

### yield关键字实现

基本不会使用这种方式实现

```python
from greenlet import greenlet

def func1():
    yield 1
    yield from func2()
    yield 2
    
def func2():
    yield 3
    yield 4
    
f1 = func1()
for item in f1:
    print(item)
```

### asyncio

在python3.4及以后的版本

强大之处在于遇到io阻塞时会自动切换协程 

```python
import asyncio

@asyncio.coroutine
def func1():
    print(1)
    yield from asyncio.sleep(2)
    print(2)
    
@asyncio.coroutine
def func2():
    print(3)
    yield from asyncio.sleep(2)
    print(4)
    
tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2()),
]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
```

### async / await 关键字

本质上和上面差不多，就是语法要简洁一些

现在基本上都只使用这种方式进行协程的编写

```python
import asyncio


async def func1():
    print(1)
    await asyncio.sleep(2)
    print(2)
    
async def func2():
    print(3)
    await asyncio.sleep(2)
    print(4)
    
tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2()),
]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
```

协程的意义

在一个线程中如果遇到IO等待时间，线程不会傻等，利用空闲的时间再去完成一些其他的任务。

##  asyncio详解

### 事件循环



