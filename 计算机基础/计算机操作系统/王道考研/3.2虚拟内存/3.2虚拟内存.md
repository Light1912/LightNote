# 3.2 虚拟内存

# 虚拟内存的基本概念

![image-20210216000100508](images/image-20210216000100508.png)

![image-20210216000110834](images/image-20210216000110834.png)

## 传统存储管理方式

![image-20210216000155640](images/image-20210216000155640.png)

**一次性**：**作业必须一次性全部装入内存后才能开始运行**。这会造成两个问题：

①作业很大时，不能全部装入内存，导致大作业无法运行；

②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

**驻留性**：一旦作业被装入内存，就**会一直驻留在内存**中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

## 局部性原理

**时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

![image-20210216000358694](images/image-20210216000358694.png)

快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中

**高速缓冲技术**的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中

## 虚拟内存的定义和特征

### 定义

基于局部性原理，在程序装入时，可以将程序中**很快会用到的部分装入内存，暂时用不到的部分留在外存**，就可以让程序开始执行。

在程序执行过程中，当所访问的**信息不在内存**时，由**操作系统负责将所需信息从外存调入内存**，然后继续执行程序。

若内存空间不够，由**操作系统负责**将内存中**暂时用不到的信息换出到外存**。

在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**

> 操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充。

易混知识点：

虚拟内存的**最大容量**是由计算机的地址结构（CPU寻址范围）确定的
虚拟内存的**实际容量**= min（内存和外存容量之和，CPU寻址范围）

如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。
则虚拟内存的最大容量为2^32^ B=4GB|
虚拟内存的实际容量=min(2^32^B,512MB+2GB)=2GB+512MB

### 特征

**多次性**：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。

**对换性**：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。

**虚拟性**：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

## 如何实现虚拟内存技术

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上。

![image-20210216001016280](images/image-20210216001016280.png)

主要区别：

在程序**执行过程中**，当**所访问的信息不在内存时**，由操作系统负责**将所需信息从外存调入内存**，然后继续执行程序。

> 操作系统要提供请求调页（或请求调段）功能

若**内存空间不够**，由操作系统负责**将内存中暂时用不到的信息换出到外存**。

> 操作系统要提供页面置换（或段置换）的功能

## 总结

![image-20210216001156422](images/image-20210216001156422.png)

# 请求分页管理方式

![image-20210216001354460](images/image-20210216001354460.png)

**请求分页**存储管理与**基本分页**存储管理的主要**区别**：

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

## 页表机制

与基本分页管理相比，请求分页管理中，为了实现“**请求调页**”，操作系统**需要知道每个页面是否已经调入内存**；如果还没调入，那么也需要知道该**页面在外存中存放的位置**

当内存空间不够时，要实现“**页面置换**”，操作系统需要通过某些指标来**决定到底换出哪个页面**；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。

与基本分页存储管理的页表相比，增加了4个字段

**![image-20210216001532091](images/image-20210216001532091.png)**

- 状态位：是否已调入内存
- 访问字段：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考
- 修改位：页面调入内存后是否被修改过
- 外存地址：页面在外存中的存放位置

## 缺页中断机构



![image-20210216001829332](images/image-20210216001829332.png)

假设此时要访问逻辑地址=（页号，页内偏移量）=（0,1024）

初始状态

![image-20210216002028370](images/image-20210216002028370.png)

在请求分页系统中，每当**要访问的页面不在内存时**，便产生一个**缺页中断**，然后由操作系统的缺页中断处理程序处理中断。

此时缺页的进程阻塞，放入阻塞队列，**调页完成后再将其唤醒**，放回就绪队列。

如果内存中**有空闲块**，则为进程**分配一个空闲块**，将所缺页面装入该块，并修改页表中相应的页表项。

![image-20210216002055011](images/image-20210216002055011.png)

如果内存中**没有空闲块**，则**由页面置换算法选择一个页面淘汰**，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存

![image-20210216002119447](images/image-20210216002119447.png)

**缺页中断**是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于**内中断**

一条指令在执行期间，**可能产生多次缺页中断**。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）

![image-20210216002217243](images/image-20210216002217243.png)

## 地址变换机构

新增步骤1：请求调页（查到页表项时进行判断）

新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）

新增步骤3：需要修改请求页表中新增的表项

![image-20210216002422474](images/image-20210216002422474.png)

①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。

②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。

③需要用某种“页面置换算法”来决定一个换出页面（下节内容）

④换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销。

⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。

![image-20210216002802919](images/image-20210216002802919.png)

在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：

查快表(未命中)
查慢表(发现未调入内存)
调页(调入的页面对应的表项会直接加入快表)

查快表(命中)
访问目标内存单元

## 总结

![image-20210216002933770](images/image-20210216002933770.png)

# 页面置换算法

![image-20210216003152811](images/image-20210216003152811.png)

## 最佳置换算法（OPT）

最佳置换算法（OPT，Optimal）：每次选择**淘汰的页面**将是**以后永不使用**，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率

例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：

7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1

![image-20210216003405529](images/image-20210216003405529.png)

第一次淘汰7号页面，选择从0，1，7中淘汰一页。按最佳置换的规则，往后寻找，最后一个出现的页号就是要淘汰的页面

整个过程缺页中断发生了9次，页面置换发生了6次。

**缺页率**=9/20=45%

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。

## 先进先出置换算法（FIFO）

先进先出置换算法（FIFO）：每次选择**淘汰的页面**是**最早进入内存的页面**

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。

例：假设系统为某进程分配了<u>三个</u>内存块，并考虑到有以下页面号引用串：

3,2,1,0,3,2,4,3,2,1,0,4

![image-20210216003728498](images/image-20210216003728498.png)

假设分配4个内存块

![image-20210216003806695](images/image-20210216003806695.png)

分配四个内存块时，缺页次数：**10次**

分配三个内存块时，缺页次数：**9次**

**Belady异常**——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

**只有FIFO算法**会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，**算法性能差**

## 最近最久未使用置换算法（LRU）

最近最久未使用置换算法（LRU，least recently used）：每次淘汰的页面是最近最久未使用的页面

实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

该算法的实现需要专门的硬件支持，虽然算法**性能好**，但是实现困难，**开销大**

例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串

1,8,1,7,8,2,7,2,1,8,3,8,2,1,3,1,7,1,3,7

![image-20210216004040969](images/image-20210216004040969.png)

在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。

## 时钟置换算法（CLOCK）

最佳置换算法性能最好，但无法实现；
先进先出置换算法实现简单，但算法性能差；
最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。
**时钟置换算法**是一种性能和开销较均衡的算法，又称**CLOCK算法**，或**最近未用算法**（**NRU**，Not Recently Used）

简单的CLOCK算法实现方法：

- 为每个页面设置一个访问位，再将内存中的页面都通过链接指针**链接成一个循环队列**。当某页

> 访问位为1，表示最近访问过；访问位为0，表示最近没访问过

- 被访问时，其访问位置为1。
- 当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）

例：假设系统为某进程分配了五个内存块，并考虑到有以下页面号引用串：1,3,4,2,5,6,3,4,7

一开始访问了1,3,4,2,5，将他们都置为1

![image-20210216004700085](images/image-20210216004700085.png)

到6时，发生了缺页

从1号开始扫描，扫描一圈过后，访问位变成0

![image-20210216004730875](images/image-20210216004730875.png)

1号页被6号页替换，指针变到下一位

![image-20210216004811655](images/image-20210216004811655.png)

接下来访问3,4，把他们的访问位置为1

![image-20210216005005635](images/image-20210216005005635.png)

访问7号页面，缺页中断，依次扫描，扫描到3和4，把他们的访问位置为0

发现2号页面的访问位是0，替换2号页面

![image-20210216005056178](images/image-20210216005056178.png)

## 改进型的时钟置换算法

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。

事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。

因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应**优先淘汰没有修改过的页面**，避免I/O操作。

这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。

为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。

**算法规则**：将所有可能被置换的页面排成一个循环队列

第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位

第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。本轮将所有扫描过的帧访问位设为0

第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位

第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。

由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此**改进型CLOCK置换算法**选择一个淘汰页面**最多会进行四轮扫描**

例子1：第一轮就找到了（0,0）

![image-20210216005421491](images/image-20210216005421491.png)

![image-20210216005442701](images/image-20210216005442701.png)

例2：需要两轮扫描

![image-20210216005537021](images/image-20210216005537021.png)

例3：需要3轮扫描

![image-20210216005611662](images/image-20210216005611662.png)

例4：需要4轮扫描

![image-20210216005640906](images/image-20210216005640906.png)

淘汰优先级：

第一优先级：最近没访问，且没修改的页面
第二优先级：最近没访问，但修改过的页面
第三优先级：最近访问过，但没修改的页面
第四优先级：最近访问过，且修改过的页面

## 总结

![image-20210216005745109](images/image-20210216005745109.png)

# 页面分配策略

> 给每个进程分配多少个页面在内存。（其他放到外边）

![image-20210216005810508](images/image-20210216005810508.png)



## 驻留集

指请求分页存储管理中给进程分配的物理块的集合。

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小

> 考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页

若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少

驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。

## 页面分配、置换策略

**固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小**不变**。

**可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小**可变**。

**局部置换**：发生缺页时只能选进程自己的物理块进行置换。

**全局置换**：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

![image-20210216010222317](images/image-20210216010222317.png)

### 固定分配局部置换

系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。

若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。

**缺点**：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）

### 可变分配全局置换

刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。

当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个**未锁定**的页面换出外存，再将该物理块分配给缺页的进程。

> 系统会锁定一些页面，这些页面中的内容不能置换出外存（如：重要的内核数据可以设为“锁定”）

采用这种策略时，**只要某进程发生缺页，都将获得新的物理块**，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。

被选择调出的页可能是系统中任何一个进程中的页，因此这个**被选中的进程**拥有的**物理块会减少**，**缺页率会增加**。

### 可变分配局部置换

刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。

如果进程在运行中**频繁地缺页**，系统会为该进程**多分配**几个物理块，直至该进程缺页率趋势适当程度；

反之，如果进程在运行中**缺页率特别低**，则可**适当减少**分配给该进程的物理块。

> 可变分配全局置换：只要缺页就给分配新物理块
>
> 可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块

## 何时调入页面

### 预调页策略

根据**局部性原理**，一次调入若干个相邻的页面可能比一次调入一个页面更高效。

> 主要指**空间局部性**，即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元

但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。

故这种策略**主要用于进程的首次调入**，由程序员指出应该先调入哪些部分。

### 请求调页策略

进程在**运行期间**发现缺页时才将所缺页面调入内存。

由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。

## 从何处调入页面

**系统拥有足够的对换区空间**：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。

![image-20210216010935192](images/image-20210216010935192.png)

**系统缺少足够的对换区空间**：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。

![image-20210216011002664](images/image-20210216011002664.png)

**UNIX方式**：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

![image-20210216011055013](images/image-20210216011055013.png)

## 抖动（颠簸）现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种**频繁的页面调度行为称为抖动**，或颠簸。

产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（**分配给进程的物理块不够**）

> 为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率
>
> 为了研究为应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念

## 工作集

**驻留集**：指请求分页存储管理中给进程分配的内存块的集合。

**工作集**：指在某段时间间隔里，进程实际访问页面的集合。

操作系统会根据“窗口尺寸”来算出工作集。例：某进程的页面访问序列如下，窗口尺寸为4，各时刻的工作集为？

![image-20210216011403095](images/image-20210216011403095.png)

**工作集大小**可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。

如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。

一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。

拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰

## 总结

![image-20210216011537218](images/image-20210216011537218.png)

