# 敌人的制作

[《勇士传说》横版卷轴动作类游戏开发教程 | Unity 中文课堂 (u3d.cn)](https://learn.u3d.cn/tutorial/2DAdventure?chapterId=64095814700410001fd87304#)

> 不写public、private修饰符的话默认是private变量。

## 1.野猪 - 基本的移动逻辑和动画

### 提纲

初始化敌人相关的代码，创建`Scripts/Enemy`文件夹，用于保存所有关于敌人的代码，文件夹下有2个文件。

```
└── Enemy
    ├── Boar.cs
    └── Enemy.cs
```

- 修改`Enemy.cs`，定义以下基本参数
  - `normalSpeed` ：float 正常移动时的速度（面板中设为100）
  - `chaseSpeed` ：float 追击敌人时的速度（面板中设为260）
  - `currentSpeed` ：float 当前速度（在`Awake()`中初始化为`normalSpeed`）
  - `faceDir`：Vector3 面朝的方向
- 获取刚体组件命名为`rb`、动画组件命名为`anim`。
  - `anim`的权限设置为`protected`
  - 在`Awake()`函数中获取这些组件的使用权。
- 修改`Boar.cs`野猪类，继承`Enemy`类

实现野猪朝固定方向移动，继续修改`Enemy.cs`

- 在`Update()`方法中判断面朝方向，实时更新
- 定义一个`Move()`方法，实现敌人移动
  - 该Move方法是一个虚（virtual）方法，表示可以被子类覆写。
  - 修改刚体的速度
- 将`Move()`方法放到`FixedUpdate()`中去执行。

创建野猪动画

首先创建动画文件结构

```
Assets/Animations
└── Enemies
    ├── Boar.cs
    └── Enemy.cs
```

- 右键 Boar 文件夹创建 Animator Controller 命名为 Boar
- 为Boar对象挂载组件Animator，并修改Controller为刚刚创建的Boar
- 为野猪对象创建动画
  - BoarIdle
  - BoarWalk
  - BoarRun
- 通过Bool参数更改野猪的动画状态
  - 创建bool参数 walk
  - 创建bool参数 run
- 联机状态转移线（Idle，wark，run）共6条线
- 修改`Boar.cs`，重写（override）Move方法。添加一个播放动画的代码。默认播放行走动画。



### 提示

protected的作用：使子类可以调用父类方法，其他类不能调用。

动画创建仍然需要设置图片参数并切分，图片参数的设置：

- **Sprite Mode**： Multiple
- **Pixels Per Unit**：16
- **Filter Mode**：Point (no filter)
- **Compressing**：None

状态转移线的设置：

- Has Exit Time :x:
- Fixed Duration :x:
- Transition Duration (%)：0

面朝方向怎么判断

> 观察Transform可以发现，当前野猪朝左，而Scale 中的 X是正数1，说明正1对应左侧，负1对应右侧。
>
> 而左侧的方向是负一，因此朝左的方向应该是 `-transform.localScale.x`。

### 完整代码

`Enemy.cs`

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MonoBehaviour
{
    [Header("基本参数")]
    public float normalSpeed;
    public float chaseSpeed;
    public float currentSpeed;
    public Vector3 faceDir;

    Rigidbody2D rb;
    protected Animator anim;

    private void Awake() {
        rb = GetComponent<Rigidbody2D>();
        anim = GetComponent<Animator>();
        currentSpeed = normalSpeed;
    }

    private void Update() {
        // 实时更新面朝方向
        faceDir = new Vector3(-transform.localScale.x, 0, 0);
    }
    private void FixedUpdate() {
        Move();
    }
    public virtual void Move() {
        rb.velocity = new Vector2(currentSpeed * faceDir.x * Time.deltaTime ,rb.velocity.y);
    }
}
```

`Boar.cs`

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Boar : Enemy
{
    public override void Move()
    {
        base.Move();
        anim.SetBool("walk", true);
    }
}

```

## 2.野猪 - 撞墙判定和等候计时

### 提纲

**实现碰撞检测**：修改`PhysicsCheck.cs`组件

- 添加检测参数
  - leftOffset：Vector2 向左偏移量
  - rightOffset：Vector2 向右偏移量
- 添加状态参数
  - touchLeftWall：bool
  - touchRightWall：bool
- 在 Check() 内添加检测碰撞代码
- 在`OnDrawGizmosSelected()` 添加Gizmo可视化代码

**调整碰撞检测**：给Boar野猪对象挂载**PhysicsCheck**组件，并设置参数

- CheckRadius ：调整到合适大小
- GroundLayer：Ground
- 调整Bottom Offset，检测野猪**前下方**有没有地面。
- 调整Left Offset，检测野猪**前方**有没有撞墙。
- 调整Right Offset，检测野猪**后方**有没有撞墙。

调整人物的PhysicsCheck组件，使得能够检测前后的碰撞

可以发现，手动确实可以调整，但是对象变多怎么办？？要是可以自动根据碰撞体形状判断岂不是更好？

**自动设置碰撞检测位置**：继续修改**PhysicsCheck**组件

- 添加检测参数
  - manual：bool
- 获取胶囊碰撞体组件
- 碰撞体组件通过Awake赋值
- 在`Awake()`方法中添加自动寻找位置的代码
- 修改Grid > Platform对象的Geometry Type为 Polygons（之前是Outlines，只有边缘线会检测）

**实现野猪撞墙掉头**，修改`Enemy.cs`

- 添加变量
  - 胶囊碰撞体
  - 在Update中判断是否撞墙，撞墙就让野猪转身。
- 修改 `Update()` 方法，使其能掉头
  - 使用physicsCheck组件看看是否撞墙。

**撞墙等待后再掉头**：修改`Enemy.cs`

- 添加新的参数列表**“计时器”**
  - waitTime：float
  - waitTimeCounter：float
  - wait：bool
- 创建计时器相关的函数`TimeCounter()`：写一个定时器
  - 判断是否是wait状态
  - 若是，开始减waitTimeCounter，直到其归零。将wait设为false
  - 修改撞墙条件判断，要面朝方向的检测点撞墙才行
  - 撞墙后设置wait变量为true
  - 撞墙后设置动画走路的参数`walk`为false。
  - 给waitTimeCounter赋初始值



### 实现碰撞检测

修改`PhysicsCheck.cs`组件

- 添加检测参数
  - leftOffset：Vector2 向左偏移量
  - rightOffset：Vector2 向右偏移量
- 添加状态参数
  - touchLeftWall：bool
  - touchRightWall：bool
- 在 Check() 内添加检测碰撞代码
- 在`OnDrawGizmosSelected()` 添加Gizmo可视化代码

```c#
public class PhysicsCheck : MonoBehaviour
{
    
    [Header("检测参数")]
    public bool manual;
    public Vector2 leftOffset;
    public Vector2 rightOffset;
    
    [Header("状态")]
    public bool touchLeftWall;
    public bool touchRightWall;
    
    public void Check()
    {
        // 墙体判断
        touchLeftWall = Physics2D.OverlapCircle((Vector2)transform.position + leftOffset, checkRadius, groundLayer);
        touchRightWall = Physics2D.OverlapCircle((Vector2)transform.position + rightOffset, checkRadius, groundLayer);
    }
    private void OnDrawGizmosSelected() {
        Gizmos.DrawWireSphere((Vector2)transform.position + leftOffset, checkRadius);
        Gizmos.DrawWireSphere((Vector2)transform.position + rightOffset, checkRadius);
    }
}
```

### 调整碰撞检测位置

给Boar野猪对象挂载**PhysicsCheck**组件，并设置参数

- CheckRadius ：调整到合适大小
- GroundLayer：Ground
- 调整Bottom Offset，检测野猪**前下方**有没有地面。
- 调整Left Offset，检测野猪**前方**有没有撞墙。
- 调整Right Offset，检测野猪**后方**有没有撞墙。

<img src="./images/image-20230407232543736.png" alt="image-20230407232543736" style="zoom:67%;" />

调整人物的PhysicsCheck组件，使得能够检测前后的碰撞

可以发现，手动确实可以调整，但是对象变多怎么办？？要是可以自动根据碰撞体形状判断岂不是更好？



### 自动设置碰撞检测位置

继续修改**PhysicsCheck**组件

- 添加检测参数
  - manual：bool
- 获取胶囊碰撞体组件
- 碰撞体组件通过Awake赋值
- 在`Awake()`方法中添加自动寻找位置的代码
- 修改Grid > Platform对象`Composite Collider 2D`组件的`Geometry Type为 Polygons`（之前是Outlines，只有边缘线会检测）

```c#
public class PhysicsCheck : MonoBehaviour
{
    CapsuleCollider2D coll;
    [Header("检测参数")]
    // 是否手动设置检测范围
    public bool manual;
    
    private void Awake() {
        coll = GetComponent<CapsuleCollider2D>();
        if (!manual)
        {
			// 这部分的代码有待优化
            rightOffset = new Vector2(coll.bounds.size.x / 2 + coll.offset.x , coll.bounds.size.y / 2);
            leftOffset = new Vector2(-rightOffset.x - checkRadius, rightOffset.y);
        }
    }
}
```

<img src="./images/image-20230407233106213.png" alt="image-20230407233106213" style="zoom:67%;" />



### 实现野猪撞墙掉头

修改`Enemy.cs`

- 添加变量
  - 获取PhysicsCheck组件
  - 在Update中判断是否撞墙，撞墙就让野猪转身。
- 修改 `Update()` 方法，使其能掉头
  - 使用physicsCheck组件看看是否撞墙。

```c#
public class Enemy : MonoBehaviour
{
    PhysicsCheck physicsCheck;
    private void Update() {
        faceDir = new Vector3(-transform.localScale.x, 0, 0);
        // Vector3 scale = transform.localScale;

        // 老师写的
        if (physicsCheck.touchLeftWall || physicsCheck.touchRightWall)) {
            // 这种感觉有问题，撞墙是一个连续的状态，会不断更改猪的方向
            transform.localScale = new Vector3(faceDir.x, 1, 1);
        }

        // 自己写的改版
        // if (physicsCheck.touchLeftWall) {
        //     transform.localScale = new Vector3(-1, 1, 1);
        // }
        // else if (physicsCheck.touchRightWall) {
        //     transform.localScale = new Vector3(1, 1, 1);
        // }
    }
}
```

### 撞墙等待后再掉头

倒计时结束后再翻转，修改`Enemy.cs`

- 添加新的参数列表**“计时器”**
  - waitTime：float
  - waitTimeCounter：float
  - wait：bool
- 创建计时器相关的函数`TimeCounter()`：写一个定时器
  - 判断是否是wait状态
  - 若是，开始减waitTimeCounter，直到其归零。将wait设为false，初始化waitTimeCounter
  - 在Awake()中给waitTimeCounter赋初始值
- 修改update()中撞墙条件的判断
  - 修改撞墙条件判断，要面朝方向的检测点撞墙才行
  - 撞墙后设置wait变量为true
  - 撞墙后设置动画走路的参数`walk`为false。

```c#
public class Enemy : MonoBehaviour
{
    [Header("计时器")]
    public float waitTime;
    public float waitTimeCounter;
    public bool wait;

    public void TimeCounter()
    {
        if (wait)
        {
            waitTimeCounter -= Time.deltaTime;
            if (waitTimeCounter <= 0)
            {
                wait = false;
                waitTimeCounter = waitTime;
                transform.localScale = new Vector3(faceDir.x, 1, 1);
            }
        }
    }
}
```

> 注意这里要修改isGround 的判断方法

```c#
    public void Check()
    {
        // 地面判断
        // isGround = Physics2D.OverlapCircle((Vector2)transform.position + bottomOffset, checkRadius, groundLayer);
        isGround = Physics2D.OverlapCircle((Vector2)transform.position + new Vector2(bottomOffset.x * transform.localScale.x, bottomOffset.y), checkRadius, groundLayer);
    }
```



### 完整代码

- [3_2_Boar.cs](src/3_2_Boar.cs)
- [3_2_Enemy.cs](src/3_2_Enemy.cs)
- [3_2_PhysicsCheck.cs](src/3_2_PhysicsCheck.cs)
- [3_2_PlayerController.cs](src/3_2_PlayerController.cs)

## 3.野猪 - 受伤及死亡的逻辑和动画

### 提纲

**跳跃时不能攻击**（可选）

**受伤和死亡动画**

- 创建野猪的受伤动画
- 创建野猪的死亡动画，由于素材中没有野猪死亡的动画，可以用受伤的动画修改一下代替死亡动画。具体实现可以让野猪的透明度降为0。
- 动画转移设置
  - Any State -> BoarHurt：播放完动画后退出
  - Any State -> BoarDead：记得取消循环播放
  - BoarHurt -> Exit
- 动画参数设置
  - dead：bool 是否死亡
  - hurt：bool 是否受伤

**受伤的代码逻辑**：修改`Enemy.cs`

- 新增基本参数
  - `public Transformer attacker`：攻击野猪的对象的Transformer（玩家的Transformer）
- 新增方法`OnTakeDamage()`
  - 参数为玩家的Transformer
  - 实现野猪转身，如果野猪背对玩家，被攻击后要面朝玩家。
- 在Boar对象的Character组件中，设置On Take Damage。

### 跳跃时不能攻击

可以设置，也可以不设置，讲道理跳跃时也能攻击

```c#
private void PlayerAttack(InputAction.CallbackContext obj)
{
    if (!physicsCheck.isGround)
        return;
    playerAnimation.PlayAttack();
    isAttack = true;
}
```

### 受伤和死亡动画

- 创建野猪的受伤动画
- 创建野猪的死亡动画
- 动画转移设置
  - Any State -> BoarHurt：播放完动画后退出
  - Any State -> BoarDead：记得取消循环播放
  - BoarHurt -> Exit
- 动画参数设置
  - dead：bool 是否死亡
  - hurt：trigger 是否受伤

野猪受伤动画用`Assets/Art Assets/Legacy-Fantasy-High Forest/Enemies/Boar/Hit-Vanish/Hit-Sheet.png`

由于素材中没有野猪死亡的动画，可以用受伤的动画修改一下代替死亡动画。具体实现可以让野猪的透明度在最后一帧降为0。

<img src="./images/image-20230408202537292.png" alt="image-20230408202537292" style="zoom:67%;" />

动画转移设置和动画参数设置

<img src="./images/image-20230408202657047.png" alt="image-20230408202657047" style="zoom:67%;" />

### 受伤的代码逻辑

修改`Enemy.cs`

- 新增基本参数
  - `public Transformer attacker`：攻击野猪的对象的Transformer（玩家的Transformer）
  - `public float hurtForce`：野猪受到伤害时，被击退的力。可以设为4.5
- 新增状态
  - `public bool isHurt`
- 修改FixedUpdate中的移动相关代码，改为非受伤状态下才能移动
- 新增方法`OnTakeDamage()`
  - 参数为玩家的Transformer
  - 实现野猪转身，如果野猪背对玩家，被攻击后要面朝玩家。
  - 实现受伤被击退的效果
- 在Boar对象的Character组件中，设置On Take Damage。

```c#
public class Enemy : MonoBehaviour
{
    [Header("基本参数")]
    public Transform attacker;
    // 受到伤害时，野猪被击退的力
    public float hurtForce;
    [Header("状态")]
    public bool isHurt;
    
    private void FixedUpdate() {
        if (!isHurt)
            Move();
    }
    public void OnTakeDamage(Transform attackTrans)
    {
        attacker = attackTrans;
        // 受到攻击转身
        if (attackTrans.position.x - transform.position.x > 0)
            transform.localScale = new Vector3(-1, 1, 1);
        if (attackTrans.position.x - transform.position.x < 0)
            transform.localScale = new Vector3(1, 1, 1);
        // 受伤被击退
        isHurt = true;
        anim.SetTrigger("hurt");
        Vector2 dir = new Vector2(transform.position.x - attackTrans.position.x, 0).normalized;

        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);
    }
}
```

设置好On Take Damage的关联方法。

<img src="./images/image-20230408203546804.png" alt="image-20230408203546804" style="zoom:67%;" />

### 协程实现受伤停止

- 创建一个协程方法`OnHurt()`
  - 在协程内给对象施加一个力
  - 协程返回的写法，等待一定时间
  - 将isHurt设置为false

此时当野猪受攻击以后，就停止不动了。我们需要用一种方式，让野猪受到攻击以后停顿一段时间再移动。

IEumerator 就是携程返回的一个迭代器对象，使用协程的方式可以帮助我们按照一定的顺序执行代码。

```c#
public class Enemy : MonoBehaviour
{
    public void OnTakeDamage(Transform attackTrans)
    {
        // 受伤被击退
        isHurt = true;
        anim.SetTrigger("hurt");
        Vector2 dir = new Vector2(transform.position.x - attackTrans.position.x, 0).normalized;
        // 开启协程
        StartCoroutine(OnHurt(dir));
    }
    private IEnumerator OnHurt(Vector2 dir)
    {
        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);
        yield return new WaitForSeconds(0.45f);
        isHurt = false;
    }
}
```





### 实现野猪死亡

修改`Enemy.cs`

- 新增状态
  - `public bool isHurt`
- 更改敌人移动条件，死亡时不能移动
- 创建销毁对象方法`DestroyAfterAnimation()`
- :star:在BoarDead动画里的最后添加一个函数事件，调用`DestroyAfterAnimation()`
- 野猪死亡时关闭野猪碰撞体

```c#
public class Enemy : MonoBehaviour
{
    [Header("状态")]
    public bool isDead;
    private void FixedUpdate() {
        if (!isHurt & !isDead)
            Move();
    }
    public void OnDie()
    {
        anim.SetBool("dead", true);
        isDead = true;
    }
    
    public void DestroyAfterAnimation()
    {
        Destroy(this.gameObject);
    }
}
```

在动画的最后一帧插入事件

<img src="./images/image-20230408211334961.png" alt="image-20230408211334961" style="zoom:67%;" />

野猪死亡时关闭野猪碰撞体

通过调整碰撞图层的方式 Edit -> Project Settings 查看Physics2D的Layer Collision Matrix。取消勾选ignore Raycast和Player的碰撞关系。

<img src="./images/image-20230408214616219.png" alt="image-20230408214616219" style="zoom:67%;" />

当野猪死亡时，把野猪的Layer改成 Ignore Raycast即可

<img src="./images/image-20230408214732797.png" alt="image-20230408214732797" style="zoom:67%;" />

修改代码`Enemy.cs`

```c#
    public void OnDie()
    {
        gameObject.layer = 2;
        anim.SetBool("dead", true);
        isDead = true;
    }
```

## 4.有限状态机&抽象类多态

之前写的`AttackFinish.cs`就是一个状态机

状态机需要控制状态进入、退出、更新时要执行什么函数

### 创建抽象类

创建`Scirpts/Enemy/BaseState.cs`

```c#
// 注意这个脚本头部不需要引入其他库
public abstract class BaseState
{
    protected Enemy currentEnemy;
    public abstract void OnEnter(Enemy enemy);
    
    // 撞墙等逻辑判断，在update中执行
    public abstract void LogicUpdate();
    public abstract void PhysicsUpdate();
    public abstract void OnExit();
}
```

注意到`AttackFinish.cs`中，定义的方法是用`virtural`，这是因为它继承了`ScriptableObject`。这个类里面进行了一些操作。所以可以用`virtural`，而我们还是用

```c#
// StateMachineBehaviour对象
    public abstract class StateMachineBehaviour : ScriptableObject
    {
        protected StateMachineBehaviour();
        public virtual void OnStateEnter(...);
        public virtual void OnStateExit(...)
    }
```

我们没有进行额外的操作，因此定义方法时需要用`abstract`关键字。

### 创建野猪巡逻状态类

`Scirpts/Enemy/BoarPatrolState.cs`

```c#

public class BoarPatrolState : BaseState
{

    public override void OnEnter(Enemy enemy)
    {
        // 发现Player 切换到 chase
        throw new System.NotImplementedException();
    }
    public override void LogicUpdate()
    {
        throw new System.NotImplementedException();
    }
    public override void OnExit()
    {
        throw new System.NotImplementedException();
    }
    public override void PhysicsUpdate()
    {
        throw new System.NotImplementedException();
    }

}
```

### 使用状态机

修改`Enemy.cs`

```c#
public class Enemy : MonoBehaviour
{
    [Header("状态")]
    
    protected BaseState currentState;
    protected BaseState patrolState;
    protected BaseState chaseState;
    
    private void OnEnable()
    {
        currentState = patrolState;
        currentState.OnEnter(this);
    }
    // 对象被关闭，消失前执行
    private void OnDisable()
    {
        currentState.OnExit();
    }
    private void Update()
    {
        // ...
        currentState.LogicUpdate();
        // old
        TimeCounter(); 
    }
    private void FixedUpdate()
    {
        // ...
        currentState.PhysicsUpdate();
    }
    

}
```

### 编写Boar对象的状态

继续完善`BoarPatrolState.cs`

```c#

public class BoarPatrolState : BaseState
{

    public override void OnEnter(Enemy enemy)
    {
        // 发现Player 切换到 chase
        currentEnemy = enemy;
    }
    public override void LogicUpdate()
    {
        if (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall && currentEnemy.faceDir.x < 0) || (currentEnemy.physicsCheck.touchRightWall && currentEnemy.faceDir.x > 0)) {
            currentEnemy.wait = true;
            currentEnemy.anim.SetBool("walk", false);
        }
        else
        {
            currentEnemy.anim.SetBool("walk", true);
        }
    }
    public override void OnExit()
    {
        currentEnemy.anim.SetBool("walk", false);
    }
}
```

完善`Enemy.cs`

在unity编辑器中隐藏变量的写法：在变量前面加上`[HideInInspector]`

```c#
public class Enemy : MonoBehaviour
{
    // 改成公有变量 并在unity界面中隐藏
    [HideInInspector]public Animator anim;
    [HideInInspector]public PhysicsCheck physicsCheck;  
    // 改成virtual 方便 Boar对象重写
    protected virtual void Awake()
    { ... }

    private void Update()
    {
        // 注释掉之前写的判断野猪撞墙的代码
        // if ((physicsCheck.touchLeftWall && faceDir.x < 0) || (physicsCheck.touchRightWall && faceDir.x > 0)) {
        //     wait = true;
        //     anim.SetBool("walk", false);
        // }
        
        currentState.LogicUpdate();
        TimeCounter();  // old
    }
    private void FixedUpdate()
    {
        // wait时也不能移动
        if (!isHurt && !isDead && !wait)
        {
            Move();
        }
    }

}
```

先注释掉之前写的修改`Boar.cs`

```c#
public class Boar : Enemy
{
    protected override void Awake()
    {
        base.Awake();
        patrolState = new BoarPatrolState();
    }
    //public override void Move()
    //{
    //    base.Move();
    //    anim.SetBool("walk", true);
    //}
}
```





### 完整代码

- [BaseState.cs](./src/3_4_BaseState.cs)
- [BoarPatrolState.cs](./src/3_4_BoarPatrolState.cs)
- [Enemy.cs](./src/3_4_Enemy.cs)
- [Boar.cs](./src/3_4_Boar.cs)
