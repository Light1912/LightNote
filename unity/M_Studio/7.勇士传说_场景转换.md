# 0.完善场景

在Project窗口的文件夹Scenes下，创建新的场景`Persistent`

>  如果之前没有命名场景，可以将我们之前的场景命名为`Cave`

双击打开`Persistent`场景，删掉里面的Main Camera



> Persistent场景的作用是，每次当我们切换场景时，实际上有许多元素是保留不变的，比如相机，玩家等。这些固定不变的对象就放在Persistent。

把`Cave`场景拖拽到Hierachy，把里面固定的对象放到Persistent场景内。

<img src="./images/image-20230523223311426.png" alt="image-20230523223311426" style="zoom:67%;" />

这样，每次切换场景时，Persistent保持不动，更换另一个场景。

看上图可以注意到，Cave场景是粗体字，右键场景可以选择当前激活的场景。

<img src="./images/image-20230523223739059.png" alt="image-20230523223739059" style="zoom:67%;" />

常用的方法：

- Set Active Scene：设置当前激活的场景
- Unload Scene：卸载场景
- Remove Scene：移除场景

创建新物体时是在当前激活的场景创建的。

Todo：

- 给新场景添加摄像机边界
- 给新场景添加不同的BGM



# 1.人物可互动标识

## 创建宝箱

添加宝箱，直接从素材拖拽到Hierarchy，`Map Assets/Chest2`



设置Inspector：

```json
{
    "Sprite Mode": "Multiple",
    "Pixels Per Unit": 16,
    "Filter Mode": "Point (no filter)",
    "Compression": None
}
```

<img src="./images/image-20230523225053764.png" alt="image-20230523225053764" style="zoom:67%;" />

设置完毕后点击 Sprite Editor切分，将这个图片切分成2列1行的素材。

<img src="./images/image-20230523225307248.png" alt="image-20230523225307248" style="zoom:67%;" />

记得设置宝箱的锚点在bottom

为宝箱添加Box Collider 2D组件，勾选is Trigger



设置标签

创建一个新的Tag：Interactable，给宝箱对象设置为这个标签

## 创建人物标识

素材在：`HUD/GameButtons`

设置好属性后按16x16的方式切割。

将键盘的E的四张图片命名一下，方便后面使用

<img src="./images/image-20230523230911470.png" alt="image-20230523230911470" style="zoom:67%;" />



把其中一张E的图片拖拽到Hierachy Player对象上，作为Player对象的子物体。

将这个子物体命名为`Sign`，默认是关闭状态，为了演示可以先打开。

给这个按钮添加动画效果

首先创建新的文件夹用于存储UI的动画效果：`Assets/Animation/UI`

在这个文件夹下创建Animator Controller，命名为`Sign.controller`



为`Sign`对象其添加Animator组件，并设置Controller为`Sign.controller`

为`Sign`对象创建动画：

- `Animation/UI/KeyBoard.anim`
- `Animation/UI/ps.anim`

采样率设为8



用类似的方法，创建一个PS4按钮的动画，用红色的圆形按钮。



设置动画

创建一个空State并设置为默认的State

不设置任何连接，直接操作Animator播放对应的动画

<img src="./images/image-20230523231313910.png" alt="image-20230523231313910" style="zoom:67%;" />



### 编写代码



这里使用接口的形式来实现（不用挂载代码到Player身上了）

先把Object调整成

```
Player
  - Sign
    - Sign Sprite
```

这里的Sign Sprite 就是之前的Sign，注意将Sign的Layer改为Default

我们要进行检测，就在Sign这里挂载代码就好。

首先为Sign对象添加一个Box Collider组件

> 这里的这个碰撞体组件我的理解是相当于人物的化身，这个碰撞体碰到宝箱，就可以在人物头上显示可互动标识。

创建场景互动控制脚本代码`Scripts/Player/Sign.cs`，将该代码挂载到Sign对象上。

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.DualShock;

public class Sign : MonoBehaviour
{
    private PlayerInputControl playerInput;
    // 用于播放动画
    private Animator anim;
    public Transform playerTrans;
    // 获取按钮标识对象
    public GameObject signSprite;
    // 判断是否能按下按钮
    private bool canPress;

    private void Awake()
    {
        // 获得子物体身上的Animator
        // anim = GetComponentInChildren<Animator>();
        anim = signSprite.GetComponent<Animator>();
        playerInput = new PlayerInputControl();
        playerInput.Enable();
    }

    private void OnEnable() 
    {
        InputSystem.onActionChange += OnActionChange;
    }

    private void Update()
    {
        // 显示图标由 canPress进行控制
        signSprite.GetComponent<SpriteRenderer>().enabled = canPress;
        // 人物转向时，按钮别转
        signSprite.transform.localScale = playerTrans.localScale;
    }

    private void OnActionChange(object obj, InputActionChange actionChange)
    {
        // 指定播放的动画内容
        if (actionChange == InputActionChange.ActionStarted)
        {
            Debug.Log("enter ActionStarted");
            var device = ((InputAction)obj).activeControl.device;
            Debug.Log(device);
            switch (device.device)
            {
                case Keyboard:
                    anim.Play("KeyBoard");
                    break;
                case DualShockGamepad:
                    anim.Play("psKey");
                    break;
            }
        }
    }
    // 检测是否碰到宝箱
    private void OnTriggerStay2D(Collider2D other)
    {
        if (other.CompareTag("Interactable"))
        {
            canPress = true;
        }
    }
    private void OnTriggerExit2D(Collider2D other)
    {
        canPress = false;
    }
}

```

# 2.场景互动的逻辑实现

## 添加按键

当走到宝箱旁边，按下按键E时，就要执行开宝箱的动作。

在`Settings/PlayerInputControl`中，添加一个新的Actions，命名为**Confirm**，在里面添加实现互动按钮的按键

- 键盘的 E
- 手柄的 □（`Button East [Gamepad]`）

![image-20230528113848136](./images/image-20230528113848136.png)

## 按键绑定

修改`Player/Sign.cs`

```cs
public class Sign : MonoBehaviour
{
    // 需要获得要互动的物体
    private IInteractable targetItem;
    
    // 修改函数
    private void OnEnable() 
    {
        // 添加
        playerInput.Gameplay.Confirm.started += OnConfirm;
    } 
    
    private void OnConfirm(InputAction.CallbackContext obj)
    {
        if (canPress)
        {
            targetItem.TriggerAction();
            // 打开宝箱时播放音效
            GetComponent<AudioDefination>().PlayAudioClip();
        }
    }
    
    private void OnTriggerStay2D(Collider2D other)
    {
        if (other.CompareTag("Interactable"))
        {
            
            // 添加：当碰撞时，获取碰撞对象的接口
            targetItem = other.GetComponent<IInteractable>();
        }
    }
}
```

> 疑惑：
>
> ```cs
> targetItem = other.GetComponent<IInteractable>();
> ```
>
> 这行代码获取的是什么，是Chest对象吗
>
> 好处就是，不需要分辨是宝箱对象还是传送们对象，都可以获得



上面的逻辑思维概况一下就是：

- 绑定按下互动按钮时，要触发哪个函数（`OnConfirm()`）
- 当Sign对象碰撞到可互动对象时，获取targetItem
- 如果按下按钮，触发targeItem的 `TriggerAciton()`方法

```cs
// 1.首先需要获取按键互动的对象
targetItem = other.GetComponent<IInteractable>();

// 2.按下按键，触发一个函数
playerInput.Gameplay.Confirm.started += OnConfirm;

// 3.在这个函数里，执行按键互动对象的响应操作
private void OnConfirm(InputAction.CallbackContext obj){}

// 4.按键互动对象调用自己的方法
targetItem.TriggerAction();
```

## 实现接口

要来学习如何实现接口的方法

创建`Scripts/Utilities/IInteractable.cs`

> 接口脚本以“`I`”开头，表示Interface
>
> 接口内只需要添加接口函数的声明，这样所有继承该接口的类都要实现接口定义的函数。

```cs
public interface IInteractable
{
    void TriggerAction();
}
```

创建`Scripts/General/Chest.cs`

继承了接口后的类就需要实现`TriggerAction()`方法

- 实现宝箱按下按键的效果，以及宝箱打开关闭的效果
- 宝箱打开后，不显示可互动标识
- 宝箱打开时，播放音效
  - 给Sign对象挂载Audio Defination 。Audio Clip（）

```cs
// Chest.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Chest : MonoBehaviour, IInteractable
{
    private SpriteRenderer spriteRenderer;
    public Sprite openSprite;
    public Sprite closeSprite;
    public bool isDone;  // 宝箱是否已打开
    
    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
    }
    private void OnEnable()
    {
        spriteRenderer.sprite = isDone ? openSprite : closeSprite;
    }
    // 接口 IInteractable 声明的函数
    public void TriggerAction()
    {
        Debug.Log("Open Chest!");
        if (!isDone)
        {
            OpenChest();
        }
    }
    
    // 实现打开宝箱时，切换宝箱图片
    private void OpenChest()
    {
        spriteRenderer.sprite = openSprite;
        isDone = true;
        this.gameObject.tag = "Untagged";  // 启动宝箱后，关闭按键
    }
}
```

宝箱打开时，播放音效

- 给Sign对象挂载Audio Defination 。Audio Clip选择DM-CGS-18，取消勾选Play On Enable

代码在Sign.cs中

```cs
    private void OnConfirm(InputAction.CallbackContext obj)
    {
        if (canPress)
        {
            targetItem.TriggerAction();
            // 打开宝箱时播放音效
            GetComponent<AudioDefination>()?.PlayAudioClip();
        }
    }
```

# 3.场景管理和切换

## 使用addressable工具

是一个大包的工具，便于场景和物体的加载

先在package manager中搜索并添加Addressables插件。

<img src="./images/image-20230614232029701.png" alt="image-20230614232029701" style="zoom:67%;" />

> 可以在插件界面点击Documentation查看[Addressables的代码手册]([docs.unity3d.com/Packages/com.unity.addressables@1.21/manual/index.html](https://docs.unity3d.com/Packages/com.unity.addressables@1.21/manual/index.html))。

安装完毕后，选择Window → Asset Management → Addressables → Groups

把这个界面拖到跟Animation同一个地方

<img src="./images/image-20230614233142031.png" alt="image-20230614233142031" style="zoom:67%;" />

点击Create  Addressables Settings 创建基本的配置

此时你的Project窗口就出现了AddressableAssetsData文件夹了。

![image-20230614234230940](./images/image-20230614234230940.png)

首先，先将`Default Local Group`修改为 `Scenes`

点击我们之前创建好的场景后，就会在Inspector窗口出现一个Addressable的勾选项

<img src="./images/image-20230614235134839.png" alt="image-20230614235134839" style="zoom:67%;" />

勾选后，就会默认加载这个场景

![image-20230614235251828](./images/image-20230614235251828.png)

可以在console窗口中看见一个警告

```
A scene from the EditorBuildScenes list has been marked as addressable. It has thus been disabled in the build scenes list.  Assets/Scenes/Cave.unity
UnityEngine.GUIUtility:ProcessEvent (int,intptr,bool&)
```

意思是在File → BuildSettings 中就会默认取消勾选这个场景

<img src="./images/image-20230614235508828.png" alt="image-20230614235508828" style="zoom:67%;" />



现在，将所有场景都加载到Addressables中

<img src="./images/image-20230614235626095.png" alt="image-20230614235626095" style="zoom:67%;" />

可以全选这三个场景，右键选择 Simplify Addressable Names，简化显示的名字



下面添加预制体（**Prefab**）。比如之前做好的蜜蜂、蜗牛、野猪。因为这些对象要频繁地复制粘贴。所以把它们做成预制体。

创建文件夹 `Assets/Prefabs`用于存放预制体。将野猪、蜗牛、蜜蜂直接拖拽到这个文件夹下。会发现这些对象变成蓝色的了。



为了避免资源重复加载导致浪费，在Addressable窗口中选择New，创建新的一个分类。命名为Enemies

<img src="./images/image-20230615000244720.png" alt="image-20230615000244720" style="zoom:67%;" />

将三个敌人预制体拖拽到新的Enemies分类下。

## 创建SceneLoadEventSO

创建`Scripts/ScriptableObject/SceneLoadEventSO.cs`，场景加载的Event事件

> 输入script.. 会自动补全

编写代码

```cs
using UnityEngine;
[CreateAssetMenu(menuName = "Event/SceneLoadEventSO")]

public class SceneLoadEventSO : ScriptableObject
{
    
}
```

创建`Scripts/ScriptableObject/GameSceneSO.cs`

```cs
using UnityEngine;
using UnityEngine.AddressableAssets;

[CreateAssetMenu(menuName = "Game Scene/GameSceneSO")]
public class GameSceneSO : ScriptableObject
{
    public AssetReference sceneReference;
}
```



sceneReference：场景引用，表示是资源的引用。



创建文件`Assets/Data SO`，所有资源类型的文件都放这里面，把Event文件夹也放到这里面。

再创建文件夹`Assets/Data SO/Game Scenes`，在这个文件夹下创建一个GameSceneSO，命名为Forest

点击Forset 在Inspector窗口中选择 Scene Rerference，选择Forest场景

![image-20230615001657471](./images/image-20230615001657471.png)

同样的方法，在创建一个Cave

## 创建传送门



在Hierachy中的Forest场景，创建一个Teleport，用于实现传送相关功能

给Teleport对象添加Box Collider 2D 碰撞体，保证这个角色的脚能够碰到这个区域即可

- 勾选Is Trigger
- 将该对象的Tag标记为Interactable

创建文件夹`Scripts/Transition`

创建代码文件`Scripts/Transition/TeleportPoint.cs`

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TeleportPoint : MonoBehaviour, IInteractable
{
    public void TriggerAction()
    {
        Debug.Log("传送！");
    }
}
```

场景转换需要做的事：

- 卸载当前场景
- 加载新的场景
- 调整角色位置

在Hierarchy中创建新物体`SceneLoadManager`

创建代码`Scripts/Transition/SceneLoader.cs`

```cs
```

