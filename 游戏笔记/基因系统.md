# 基因

参考的是孟德尔

排列顺序：

## 前后排列

1000 + 1111，优点是拼接比较方便，解码略有一点点复杂

```python
# base = dna长度的一半
# dna的合并
def combine(x, y, base=4):
    return (x << base) + y

# dna的切分
def split(xy, base=4):
    x = xy >> 4
    y = xy % 2 ** base
    return x, y

# 产生子代
def generate_children(xy, base=4):
    # 生成两条DNA链
    x, y = split(xy, base=4)
```



## 交叉排列

11 01 01 01

这样在解码的时候直接从低位截断即可。生成子代的话，每间隔两个二进制位，取一个数。

```python
import random
dna = int('0b1110_0000', 2)
base = (1 << 8) - 1
print(bin(dna))

def generate_children_dna(dna, from_mother=False, length=8):
    base = (1 << length) - 1
    children_dna = 0
    for i in range(length // 2):
        use_left = random.random() > 0.5
        left = dna >> 7
        right = (dna >> 6) & 1

        children_dna = children_dna << 1
        if use_left:
            children_dna += left
        else:
            children_dna += right
        children_dna = children_dna << 1
        dna = (dna << 2) & base

    if from_mother:
        children_dna = children_dna >> 1
    return children_dna
```

子代DNA相加即可。（父亲和母亲产生的子代DNA是错位的）



变异操作。

```python
import random

def dna_mutation(dna, p=10):
    result = 0
    mask = 1
    while dna != 0:
        if random.random() < p / 100:
            result |= mask
        mask <<= 1
        dna >>= 1
    return result

a = 0b11010101
transformed_a = transform_binary_number(a, 50)
print(bin(transformed_a))

```

## 案例

```
# 一个八位的dna。随机生成
# 假设dna中带1的数量大于等于 6个，则达标，否则不达标
# 随机初始化的情况下，有多少达标的
# 不断迭代后，有多少达标的
```

用numpy模拟吧

首先生成10000个dna

```python
import numpy as np

# 创建一个函数来计算一个整数二进制表示中1的个数
def count_ones(n):
    return bin(n).count('1')

# 将这个函数转换为可以在numpy数组上操作的函数
v_count_ones = np.vectorize(count_ones)
n = 10
total = 10000
population = np.random.randint(0, 2 ** n, total)

# 使用转换后的函数计算数组中每个数字的二进制表示中1的个数
result = v_count_ones(population)

# 打印结果
print(f"总共{n}位，{total}个数")
for i in range(4):
    v = n - i
    print(f"大于等于{v}的数量: {(result >= v).sum()}, 百分比: {(result >= v).sum() / total * 100:.4f}%")
```

```
总共10位，10000个数
大于等于10的数量: 11, 百分比: 0.1100%
大于等于9的数量: 113, 百分比: 1.1300%
大于等于8的数量: 578, 百分比: 5.7800%
大于等于7的数量: 1779, 百分比: 17.7900%
```

交叉

假设现在有2个 8位二进制数，

比如  

a = 0b11001100 

b = 0b10110100 

现在希望组合 a 和b。生成一个新的8位的二进制数。每个位置上有 p的概率选择 a的数。(1-p)的概率选择 b的二进制数 需要写一个函数组合这两个二进制数

```python
import numpy as np

def combine_bits(a, b, p):
    result = 0
    for i in range(8):  # 8位
        mask = 1 << i  # 创建一个mask，用于获取a和b在特定位的值
        bit_a = a & mask
        bit_b = b & mask
        if np.random.rand() < p:  # 按照概率p选择a还是b的位
            result |= bit_a
        else:
            result |= bit_b
    return result

a = 0b11001100
b = 0b10110100
p = 0.6

result = combine_bits(a, b, p)
print(bin(result))

```

