



## 求平均暴击率

基础暴击率为5%，如果当前攻击未命中，则下一次暴击率增加10%，问：平均暴击率为多少。

~~如果赋予了基础概率值，实际上和之前差不大多~~

(以下待施工)
$$
P(N) = a + C(N-1)
$$

a为基础暴击率

C为暴击增量

N为攻击次数

攻击次数为1的时候只有基础暴击率

| N    | 第N次暴击的几率 | 之前没暴击的几率              | 第N次攻击才暴击的概率                   |
| ---- | --------------- | ----------------------------- | --------------------------------------- |
| 1    | $a$             | 1                             | $a$                                     |
| 2    | $a+C$           | $(1-a)$                       | $(a+C)(1-a)$                            |
| 3    | $a+2C$          | $(1-a)(1-a-C)$                | $(a+2C)(1-a)(1-a-C)$                    |
| n    | $a+(n-1)C$      | $\prod_{i=2}^{n}[1-a-(i-2)C]$ | $[a+(i-1)C]\prod_{i=2}^{n}[1-a-(i-2)C]$ |
| x    |                 |                               |                                         |

### 程序模拟

```python
import random
# a base_critical_probablily
# c probability_increment
def count_critical_hit(a=0.05, c=0.1):
    critical = False  # 是否暴击
    count = 0
    while not critical:
        count += 1
        if random.random() < a:
            critical = True
        else:
            a += c
    return count

def repeat_experiment(n):
    count = 0
    for i in range(n):
        count += count_critical_hit()
    return count / n

ans = repeat_experiment(1000000)
print("平均需要%.5f次攻击暴击一次" % ans)
```

```
平均需要4.11890次攻击暴击一次
```

### 理论求解（old）



对于这题，也就是$a=0.05$，$C=0.1$，求平均暴击率

```python
a = 0.05  # 基础暴击率
c = 0.1  # 暴击率增量
pn = a  # 当前暴击率
n = 1  # 第n次攻击
ans = 0
while pn < 1:
    tmp = n * (a + (n-1)*c)
    i = 2
    while i <= n:
        tmp *= (1 - a - (i - 2) * c)
        i += 1
    ans += tmp
    n += 1
    pn += c
print("平均需要%.5f次攻击暴击一次，暴击率为%.4f%%" % (ans, 1 / ans * 100))
```

```
平均需要4.11399次攻击暴击一次，暴击率为24.3073%
```



### 理论求解（new）

也用状态转换的思想，终点是暴击，一共有个状态。分别为

第一次攻击，第二次攻击，...，第十次攻击。（第十次攻击必暴击，因为此时概率累加到105%了）



e(x) 表示第x次开始攻击，直到暴击所需要的攻击次数的期望

走偏了，但是

```python
# a 基础暴击率
# c 暴击率增量
def critical_probablity(num_attack, a=0.05, c=0.1):
    return min(1, a + (num_attack - 1) * c)

def e(x):
    p = critical_probablity(x)  # 本次暴击概率
    if p >= 1:
        return 1
    else:
        # return p + (1 - p) * (e(x+1) + 1)
        return 1 + (1 - p) * e(x+1)
ans = e(1)
print("平均需要%.5f次攻击暴击一次，暴击率为%.4f%%" % (ans, 1 / ans * 100))
```

```
平均需要4.11469次攻击暴击一次，暴击率为24.3032%
```

然后到这里我发现之前的求解方式有疏漏，实际上是不对的

求离散随机变量的期望得把所有分布都考虑进来，但实际上忽略了最后一次攻击的情况。



改版

```python
def main():
    a = 0.05  # 基础暴击率
    c = 0.1  # 暴击率增量
    # 获取所有随机变量可能的取值
    distributions = get_distributions(a, c)
    # 计算所有随机变量取值的概率
    probabilities = [compute_probability(x) for x in distributions]
    
    # 返回期望
    return compute_expectation(distributions, probabilities)


# 根据随机变量分布和其概率计算期望
def compute_expectation(distributions, probabilities):
    ans = 0
    for x, p in zip(distributions, probabilities):
        ans += x * p
    return ans

# 生产随机变量分布
def get_distributions(a=0.05, c=0.1):
    distributions = [1]
    while a < 1:
        distributions.append(distributions[-1] + 1)
        a += 0.1
    return distributions

# 根据随机变量的取值计算概率
def compute_probability(x, a=0.05, c=0.1):
    # 当前暴击概率
    current_critical_probability = min(1, a + (x - 1) * c)
    
    # 之前都没暴击的概率
    never_critical_probability = 1
    for n in range(x - 1):
        never_critical_probability *= (1 - a - n * c)
    return current_critical_probability * never_critical_probability

ans = main()
print("平均需要%.5f次攻击暴击一次，暴击率为%.4f%%" % (ans, 1 / ans * 100))
```

```
平均需要4.11469次攻击暴击一次，暴击率为24.3032%
```

> 可以看出，用马尔科夫链的方式求解，代码更简洁
>
> 而且用取值*概率求期望的方式无法求解随机变量取值范围无限的情况





## 求连续n个元素需要的平均次数

有4种不同的元素，水火风电。每次获取一个元素的概率是一样的（均为25%），问平均要多少次才能集齐4种元素。

![image-20210220142917859](images/image-20210220142917859.png)

分析：

| 已获不同元素的个数 | 获得不同元素的概率 | 平均要几次才能获得不同元素 |
| ------------------ | ------------------ | -------------------------- |
| 0                  | 100%               | 1                          |
| 1                  | 75%                | 1 / 0.75 = 1.333           |
| 2                  | 50%                | 1 / 0.5 = 2                |
| 3                  | 25%                | 1 / 0.25 = 4               |

答：

平均需要1 + 1.333 + 2 + 4 = 8.333次才能集齐4种元素

例题3：有4种不同的元素，水火风电。每次获取一个元素的概率是一样的（均为25%），问平均需要多少次才能连续收集两个火元素。

分析：

分析有几种状态：

- 状态1：往前1次不是火元素
- 状态2：往前1次是火元素，往前2次不是火元素
- 状态3：往前1次是火元素，往前2次也是火元素（结束态）

状态转换的情况：

- 状态1 → 状态2：有1/4的概率收集到火元素
- 状态1 → 状态1：有3/4的概率收集到非火元素
- 状态2 → 状态3：有1/4的概率收集到火元素
- 状态2 → 状态1：有3/4的概率收集到非火元素

如果从状态1转到了状态1，那仍需要n次才能出现两个火元素。总次数就变成了n+1，这种情况的概率是3/4 * (n+1)

如果从状态1转到了状态2，又从状态2转到了状态1。总次数变成了n+2，这种情况的概率是1/4 * 3/4 * (n+2)

如果从状态1转到状态2，又从状态2转到了状态3，这种情况的概率为：1/4 * 1/4

解这个方程：3/4 * (n+1) + 1/4 * 3/4 * (n+2) + 1/4 * 1/4 = n

可以得n = 19

## 题4 数学期望

某城市有10万个家庭，没有孩子的家庭有1000个，有一个孩子的家庭有9万个，有两个孩子的家庭有6000个，有3个孩子的家庭有3000个。求平均每个家庭有多少个孩子。

则此城市中任一个家庭中孩子的数目是一个随机变量，记为X。它可取值0，1，2，3。

## 英雄升级问题

https://www.bilibili.com/video/BV17K411n7Sj

假如耗费一颗宝石可以升一级

0到1级概率：100%

1到2级概率：1/3升级1/3等级不变 1/3降级

2到3级概率：4/9升级 4/9等级不变 1/9升级

> 1级到2级平均需要多少次？
>
> 如何理解 1/3 * 1。
>
> 如何理解(1/3)(k+1)， 1/3 * (1 + E(2))，

0-1级：1

1-2级：k = (1/3)(k+2) + (1/3)(k+1) + (1/3)

```
3k = k+2 + k + 1 + 1
k = 4
```

2-3级：

```
k = (4/9)(k+5) + (4/9)(k+1) + (1/9)
9k = 4k + 20 + 4k + 4 + 1
k = 25
```



## 抽卡问题

抽卡时，每次抽取概率为：N：45%，R：50%，SR：5%。若连续29次抽取没抽出SR则下次抽取必出SR。问：平均每多少次抽取出一个SR？（若不方便给出准确答案给出计算思路亦可）（13分钟）

https://www.zhihu.com/question/382551711

这题跟马尔科夫链那题比较像

![image-20210602125259749](images/image-20210602125259749.png)

绿色圆圈表示抽到了卡的状态，蓝色圆圈的数字表示是**第几次抽卡**，总共最多会进行30次抽卡，必能抽到卡

设抽到卡的概率为p，则抽不到卡的概率为1-p，计算如下

```
p*1 + p*(1-p)*2 + p*(1-p)^2*3 + ... + + p*(1-p)^28*29  + (1-p)^29 * 30
```

程序代码如下：

```python
p = 0.05  # 抽中的概率 5%
limit = 30  # 多少抽保底
ans = 0
for i in range(1, limit, 1):
    ans += p * (1 - p) ** (i-1) * i
ans += (1 - p) ** (limit-1) * limit
print(f"平均需要 {ans:.4f} 次出SSR, 概率 {1 / ans * 100:.4f} %")
```

```
平均需要 15.7072 次出SSR, 概率 6.3665 %
```

过了许久不理解这个解法了。。。

`p*(1-p)^2*3`的含义是啥。。

大概能猜到，`p*(1-p)^2`表示第3抽抽到SSR的概率，也就是`E(3) = p * (1-p) ^ 2`



那么`p(x)`表示第X抽抽到SSR的概率，`xp(x)`表示什么？

后来搜索研究了一下，这其实就是离散随机变量的求解方法

如果X是离散型随机变量，它的全部可能取值是a1,a2,…，an,…,取这些值的相应概率是p1,p2…,pn,…,则其数学期望`E(X)=(a1)*(p1)+(a2)*(p2)+…+(an)*(pn)+…`；

> 如果要深究的话，就可以尝试理解为什么每一项是这样的。
>
> 取值是a4的概率是p4，a4 * p4的含义是啥。
>
> 把概率理解为权重，期望理解为随机变量的均值。
>
> 联系上面的例子
>
> X表示第X次抽到SR。
>
> E(X)就表示平均要花E(X)次抽到SR
>
> 然后每个次数抽到SR都有一个概率权重，加权求和就得到了平均次数。





模拟抽卡代码

```python
import random 
p = 0.05  # 抽到SSR的概率
max_count = 30
num_experiments = 1e7  # 1000万次实验

count = 0  # 连续几次没抽中
total = 0  # 总共抽中了几次SSR

for i in range(num_experiments):
    if random.random() <= p or count >= max_count - 1:
        total += 1
        count = 0
    else:
        count += 1
print("抽到SSR的概率为: %s" % (total/num_experiments))
print("平均需要 %.4f 次出SSR" % (1 / (total/num_experiments)))
```

```
抽到SSR的概率为: 0.0636677
平均需要 15.7066 次出SSR
```

### 马尔科夫链计算

后续补充的计算方案

设E(x)表示状态x转换到状态抽到卡（绿色）的期望次数。

再翻译一下：E(1) 就表示，从第一次抽卡开始，抽到SSR的期望次数

0.05 + 0.95 * (e(2) + 1) = 0.05 + 0.95E2 + 0.95 = 1 + 0.95E2



```python
def e(n):
    if n == 30:
        return 1
    else:
        return 0.05 + 0.95 * (e(n+1) + 1)
    # return 1 + 0.95 * e(n + 1)
print("平均需要 %.4f 次出SSR" % e(1))
```

```
平均需要 15.7072 次出SSR
```



## 扭蛋问题

扭蛋机里有4个不同的蛋，每次出货的概率相同，求抽到4个不同的蛋所需要的期望扭蛋次数

### 程序模拟

```python
import random
eggs = ['A', 'B', 'C', 'D']  # 四个不同的蛋的编号

# 一次实验，获得4个不同蛋所需要的扭蛋次数
def count_get_all_eggs(eggs):
    count = 0
    my_eggs = set()
    while len(my_eggs) < len(eggs):
        my_eggs.add(random.choice(eggs))
        count += 1
    return count

def repeat_experiment(n, eggs):
    avg_count = 0
    for i in range(n):
        avg_count += count_get_all_eggs(eggs)
    return avg_count / n

avg_count = repeat_experiment(10000, eggs)
print('平均 %.4f 次抽齐所有扭蛋' % avg_count)
```

```
平均 8.3555 次抽齐所有扭蛋
```

### 理论推导

已有的不同的蛋的状态一共有5种，什么也没有，到有4颗不同的蛋。 



![image-20211222150510006](images/image-20211222150510006.png)

现在要求的是从状态0到状态4所需要的扭蛋次数，每转移一次状态会消耗一个扭蛋次数。比如说状态1可能往状态2或者状态1转换，转换后消耗一次扭蛋次数。



如何求状态2转换到状态3的期望次数？

设E(3)表示状态2转换到状态3的期望次数，这里就分成了2个路径，1是状态2直接转换到了状态3，第二种是状态2又回到了状态2，然后转换到了状态3

- 路径一的期望：0.5 * 1
- 路径二的期望：0.5 * (1 + E(3))

由于又回到了路径二，相当于需要在花费一定的期望次数才能走到状态3

那么总的方程就是

E(3) = 0.5 + 0.5 * (1 + E(3))

解方程得 E(3) = 2

状态0到状态1，只需要1次

状态1到状态2，平均需要1 / 0.75 ≈ 1.333

状态2到状态3，平均需要 1 / 0.5 ≈ 2

状态3到状态4，平均需要 1 / 0.25 ≈ 4

## 状态转移矩阵

https://blog.csdn.net/jiayoudangdang/article/details/81838326
