Leetcode 347

[912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

快排:heavy_check_mark:

- 先写出模板

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        def get_pivot(nums, lo, hi):
            p = random.randint(lo, hi)
            nums[hi], nums[p] = nums[p], nums[hi]
            
            for i in range(lo, hi):
                if nums[i] < nums[hi]:
                    nums[i], nums[lo] = nums[lo], nums[i]
                    lo += 1
            nums[lo], nums[hi] = nums[hi], nums[lo]
            return lo


        def quick_sort(nums, lo, hi):
            if lo > hi:
                return 
            i = get_pivot(nums, lo, hi)
            quick_sort(nums, lo, i-1)
            quick_sort(nums, i+1, hi)
        
        quick_sort(nums, 0, len(nums)-1)
        return nums
```

堆排

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        def heapify(nums, lo, hi):
            parent = lo
            while parent * 2 + 1 < hi:
                child = parent * 2 + 1
                if child + 1 < hi and nums[child+1] > nums[child]:
                    child += 1
                if nums[child] > nums[parent]:
                    nums[parent], nums[child] = nums[child], nums[parent]
                    parent = child
                    
                else:
                    break

        def heap_sort(nums):
            # 建大根堆
            for i in range(len(nums)//2, -1, -1):
                heapify(nums, i, len(nums))

            # 每次把根移到当前长度的最后边
            for i in range(len(nums)-1, 0, -1):
                nums[0], nums[i] = nums[i], nums[0]
                heapify(nums, 0, i)
        heap_sort(nums)
        return nums
```



归并排序

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def merge_sort(nums, lo, hi):
            if lo >= hi:
                return 
            mid = (lo + hi) // 2
            merge_sort(nums, lo, mid)
            merge_sort(nums, mid+1, hi)

            # 合并
            i, j = lo, mid+1
            tmp = []
            while i <= mid or j <= hi:
                if j > hi or (i <= mid and nums[i] < nums[j]):
                    tmp.append(nums[i])
                    i += 1
                else:
                    tmp.append(nums[j])  
                    j += 1
            for i in range(len(tmp)):
                nums[lo+i] = tmp[i]
        merge_sort(nums, 0, len(nums)-1)
        return nums
```