python的bisect库。

主要区分`bisect.bisect_left(a, x, lo=0, hi=None)`和`bisect.bisect_right(a, x, lo=0, hi=None)`的区别

## bisect的用法和区别

搞清楚这两个自测小问题，你就基本弄懂这个库怎么用了

自测小问题：

- bisect_left 和 bisect_right 返回值的意义是什么？
- left 和 right的区别是什么？

回答：

假设`nums`是要进行二分查找的数组，`x`是目标值。

这个二分查找就是要找到`x`插入`nums`的哪个位置，也就是返回索引。假设数组长为3，那取值范围就是`[0, 1, 2, 3]`

- 假如`nums`内没有和`x`一样的元素，那就是查找`x`将要插入的位置
- 如果`nums`内有和`x`一样的元素
  - 对于left方法，返回的索引就是`x`第一次出现时的索引
  - 对于right方法，返回的索引就是`x`最后一次出现时的索引**+1**

```python
import bisect

# 没有和
nums = [1, 2, 2, 2, 4]
print("nums: ", nums)
print("bisect_left: ", bisect.bisect_left(nums, 2))
print("bisect_right: ", bisect.bisect_right(nums, 2))
```

输出：

```
nums:  [1, 2, 2, 2, 4]
bisect_left:  1
bisect_right:  4
```



## bisect源代码

```python
def bisect_right(a, x, lo=0, hi=None):
    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if x < a[mid]: hi = mid
        else: lo = mid+1
    return lo

def bisect_left(a, x, lo=0, hi=None):
    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x: lo = mid+1
        else: hi = mid
    return lo
```

不同点：

- 判断条件（结合left和right的定义去记忆）nums[mid] 在哪边。
  - `if x < a[mid]: hi = mid` right
  - `if a[mid] < x: lo = mid + 1` left



# 二分法

```python
def binary_select_right(nums, x, left=0, right=None):
    if right is None:
        right = len(nums)

    while left < right:
        mid = (left + right) // 2
        if x < nums[mid]: 
            right = mid
        else: 
            left = mid+1
    return left
```

## mid 的计算方式

mid的计算方式：(left + right) // 2。当两数相邻时，算出的mid等于left

例：left = 7，right=8。 mid = (7 + 8) // 2 = 15 // 2 = 7

因此在二分时，如果x > nums[mid]，更新的left = mid + 1。

否则可能出现无限循环的情况。

## 二分的核心

上面这个函数的含义：

nums是一个递增数组，要将x插入nums，且nums保持递增，若nums中包含与x相同的元素，则**将x插入到其相同元素的最右边**，返回x插入位置的索引。

其中的核心语句是：

```
if x < nums[mid]:
```

如果将上面这句改成

```
if x <= nums[mid]:
```

函数含义就变为：若nums中包含与x相同的元素，则将x插入到其相同元素的**最左边**



小于与小于等于的差异

```
x = 2

  1   2   2   2   3
  ^       ^       ^
left     mid    right
```

（1）如果按照 x < nums[mid]，条件不满足，更新 left = mid + 1

> 飞机分头等舱和经济舱，优先级分别为1和2。理所应当，优先级越小的越早登机。拿着头等舱机票的乘客在排队时可以一下子走到经济舱乘客的前面。
>
> 这时候张三购买了头等舱机票来排队了，他可以排在经济舱乘客的前面，但是按照排队先来后到的原则，他得排在头等舱乘客的最后面
>
> 虽然都是头等舱，但是还是**不一样**的（小于号，没有等于号）

（2）如果按照 x <= nums[mid]，条件满足，更新 right = mid

> 但是张三不服气，争辩到，我们都**一样**是头等舱，排哪里都无所谓啦。因此我要排到最前面。（小于等于）







