# DFS和BFS

## 树的遍历

DFS和BFS都用一个容器来存储结点。

DFS的思想，后进先出，即用一个栈来存储结点，每次pop最后一个结点。

BFS的思想，先进先出，用一个队列来存储结点，每次pop第一个结点。

先构建一颗比较简单的树

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

root = Node(0)
root.left = Node(1)
root.right = Node(2)
root.left.left = Node(3)
root.left.right = Node(4)
root.right.left = Node(5)
root.right.right = Node(6)
"""
   0
 1   2
3 4 5 6
"""
```



DFS

```python
nodes = [root]
while nodes:
    node = nodes.pop()
    if node.right:
        nodes.append(node.right)
    if node.left:
        nodes.append(node.left)
    print(node.value, end=" ")
```

```
0 1 3 4 2 5 6
```

BFS

```python
nodes = deque([root])
while nodes:
    node = nodes.popleft()
    if node.left:
        nodes.append(node.left)
    if node.right:
        nodes.append(node.right)
    print(node.value, end=" ")
```

```
0 1 2 3 4 5 6 
```

## 相关算法题

### 1254.统计封闭岛屿的数目

https://leetcode.cn/problems/number-of-closed-islands/

二维矩阵 `grid` 由 `0` （土地）和 `1` （水）组成。岛是由最大的4个方向连通的 `0` 组成的群，封闭岛是一个 `完全` 由1包围（左、上、右、下）的岛。

请返回 *封闭岛屿* 的数目。

示例1

```python
grid = [
    [1,1,1,1,1,1,1,0],
    [1,0,0,0,0,1,1,0],
    [1,0,1,0,1,1,1,0],
    [1,0,0,0,0,1,0,1],
    [1,1,1,1,1,1,1,0]
]
```



![img](images/sample_3_1610.png)

示例2：

```python
# 输入
grid = [
    [0,0,1,0,0],
    [0,1,0,1,0],
    [0,1,1,1,0]
]
# 输出：1
```

示例3：

```python
# 输入
grid = [[1,1,1,1,1,1,1],
        [1,0,0,0,0,0,1],
        [1,0,1,1,1,0,1],
        [1,0,1,0,1,0,1],
        [1,0,1,1,1,0,1],
        [1,0,0,0,0,0,1],
        [1,1,1,1,1,1,1]]
# 输出：2
```



分析思路：

应该从陆地出发，走遍连接的所有陆地，只要陆地不连接到边缘，就说明是个岛。

走过的就不再走了

```python
class Solution:
    def closedIsland(self, grid) -> int:
        def dfs(i, j):
            ans = 1
            if seen[i][j]:
                return 0

            stack = [(i, j)]
            while stack:
                i, j = stack.pop()
                seen[i][j] = 1
                for di, dj in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    next_i, next_j = i + di, j + dj
                    # 越界
                    if next_i < 0 or next_j < 0 or next_i >= height or next_j >= width:
                        ans = 0
                        continue
                    if grid[next_i][next_j] == 0 and seen[next_i][next_j] == 0:
                        stack.append((next_i, next_j))
            return ans

        height, width = len(grid), len(grid[0])
        # seen = [[0] * width] * height
        seen = [[0] * width for _ in range(height)]
        ans = 0
        for i in range(height):
            for j in range(width):
                if grid[i][j] == 0:
                    ans += dfs(i, j)
        return ans
```

> 错误分析：之前发现答案和预料的不一样，检查代码发现seen的写法出问题了，代码整体逻辑没有问题

之前是

```python
# 这种写法会导致牵一发动全身
# 例
width, height = 3, 3
seen = [[0] * width] * height
print(seen)
seen[1][1] = 1
print(seen)
```

```
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
[[0, 1, 0], [0, 1, 0], [0, 1, 0]]
```

而下面这种写法就能正确解决问题。

```python
seen = [[0] * width for _ in range(height)]
seen[1][1] = 1
print(seen)
```

```
[[0, 0, 0], [0, 1, 0], [0, 0, 0]]
```

